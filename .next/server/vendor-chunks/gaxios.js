"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/gaxios";
exports.ids = ["vendor-chunks/gaxios"];
exports.modules = {

/***/ "(rsc)/./node_modules/gaxios/build/cjs/src/common.js":
/*!*****************************************************!*\
  !*** ./node_modules/gaxios/build/cjs/src/common.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n// Copyright 2018 Google LLC\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.GaxiosError = exports.GAXIOS_ERROR_SYMBOL = void 0;\nexports.defaultErrorRedactor = defaultErrorRedactor;\nconst extend_1 = __importDefault(__webpack_require__(/*! extend */ \"(rsc)/./node_modules/extend/index.js\"));\nconst util_cjs_1 = __importDefault(__webpack_require__(/*! ./util.cjs */ \"(rsc)/./node_modules/gaxios/build/cjs/src/util.cjs\"));\nconst pkg = util_cjs_1.default.pkg;\n/**\n * Support `instanceof` operator for `GaxiosError`s in different versions of this library.\n *\n * @see {@link GaxiosError[Symbol.hasInstance]}\n */\nexports.GAXIOS_ERROR_SYMBOL = Symbol.for(`${pkg.name}-gaxios-error`);\nclass GaxiosError extends Error {\n    config;\n    response;\n    /**\n     * An error code.\n     * Can be a system error code, DOMException error name, or any error's 'code' property where it is a `string`.\n     *\n     * It is only a `number` when the cause is sourced from an API-level error (AIP-193).\n     *\n     * @see {@link https://nodejs.org/api/errors.html#errorcode error.code}\n     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/DOMException#error_names DOMException#error_names}\n     * @see {@link https://google.aip.dev/193#http11json-representation AIP-193}\n     *\n     * @example\n     * 'ECONNRESET'\n     *\n     * @example\n     * 'TimeoutError'\n     *\n     * @example\n     * 500\n     */\n    code;\n    /**\n     * An HTTP Status code.\n     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Response/status Response#status}\n     *\n     * @example\n     * 500\n     */\n    status;\n    /**\n     * @deprecated use {@link GaxiosError.cause} instead.\n     *\n     * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error/cause Error#cause}\n     *\n     * @privateRemarks\n     *\n     * We will want to remove this property later as the modern `cause` property is better suited\n     * for displaying and relaying nested errors. Keeping this here makes the resulting\n     * error log larger than it needs to be.\n     *\n     */\n    error;\n    /**\n     * Support `instanceof` operator for `GaxiosError` across builds/duplicated files.\n     *\n     * @see {@link GAXIOS_ERROR_SYMBOL}\n     * @see {@link GaxiosError[Symbol.hasInstance]}\n     * @see {@link https://github.com/microsoft/TypeScript/issues/13965#issuecomment-278570200}\n     * @see {@link https://stackoverflow.com/questions/46618852/require-and-instanceof}\n     * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/@@hasInstance#reverting_to_default_instanceof_behavior}\n     */\n    [exports.GAXIOS_ERROR_SYMBOL] = pkg.version;\n    /**\n     * Support `instanceof` operator for `GaxiosError` across builds/duplicated files.\n     *\n     * @see {@link GAXIOS_ERROR_SYMBOL}\n     * @see {@link GaxiosError[GAXIOS_ERROR_SYMBOL]}\n     */\n    static [Symbol.hasInstance](instance) {\n        if (instance &&\n            typeof instance === 'object' &&\n            exports.GAXIOS_ERROR_SYMBOL in instance &&\n            instance[exports.GAXIOS_ERROR_SYMBOL] === pkg.version) {\n            return true;\n        }\n        // fallback to native\n        return Function.prototype[Symbol.hasInstance].call(GaxiosError, instance);\n    }\n    constructor(message, config, response, cause) {\n        super(message, { cause });\n        this.config = config;\n        this.response = response;\n        this.error = cause instanceof Error ? cause : undefined;\n        // deep-copy config as we do not want to mutate\n        // the existing config for future retries/use\n        this.config = (0, extend_1.default)(true, {}, config);\n        if (this.response) {\n            this.response.config = (0, extend_1.default)(true, {}, this.response.config);\n        }\n        if (this.response) {\n            try {\n                this.response.data = translateData(this.config.responseType, \n                // workaround for `node-fetch`'s `.data` deprecation...\n                this.response?.bodyUsed ? this.response?.data : undefined);\n            }\n            catch {\n                // best effort - don't throw an error within an error\n                // we could set `this.response.config.responseType = 'unknown'`, but\n                // that would mutate future calls with this config object.\n            }\n            this.status = this.response.status;\n        }\n        if (cause instanceof DOMException) {\n            // The DOMException's equivalent to code is its name\n            // E.g.: name = `TimeoutError`, code = number\n            // https://developer.mozilla.org/en-US/docs/Web/API/DOMException/name\n            this.code = cause.name;\n        }\n        else if (cause &&\n            typeof cause === 'object' &&\n            'code' in cause &&\n            (typeof cause.code === 'string' || typeof cause.code === 'number')) {\n            this.code = cause.code;\n        }\n    }\n    /**\n     * An AIP-193 conforming error extractor.\n     *\n     * @see {@link https://google.aip.dev/193#http11json-representation AIP-193}\n     *\n     * @internal\n     * @expiremental\n     *\n     * @param res the response object\n     * @returns the extracted error information\n     */\n    static extractAPIErrorFromResponse(res, defaultErrorMessage = 'The request failed') {\n        let message = defaultErrorMessage;\n        // Use res.data as the error message\n        if (typeof res.data === 'string') {\n            message = res.data;\n        }\n        if (res.data &&\n            typeof res.data === 'object' &&\n            'error' in res.data &&\n            res.data.error &&\n            !res.ok) {\n            if (typeof res.data.error === 'string') {\n                return {\n                    message: res.data.error,\n                    code: res.status,\n                    status: res.statusText,\n                };\n            }\n            if (typeof res.data.error === 'object') {\n                // extract status from data.message\n                message =\n                    'message' in res.data.error &&\n                        typeof res.data.error.message === 'string'\n                        ? res.data.error.message\n                        : message;\n                // extract status from data.error\n                const status = 'status' in res.data.error &&\n                    typeof res.data.error.status === 'string'\n                    ? res.data.error.status\n                    : res.statusText;\n                // extract code from data.error\n                const code = 'code' in res.data.error && typeof res.data.error.code === 'number'\n                    ? res.data.error.code\n                    : res.status;\n                if ('errors' in res.data.error &&\n                    Array.isArray(res.data.error.errors)) {\n                    const errorMessages = [];\n                    for (const e of res.data.error.errors) {\n                        if (typeof e === 'object' &&\n                            'message' in e &&\n                            typeof e.message === 'string') {\n                            errorMessages.push(e.message);\n                        }\n                    }\n                    return Object.assign({\n                        message: errorMessages.join('\\n') || message,\n                        code,\n                        status,\n                    }, res.data.error);\n                }\n                return Object.assign({\n                    message,\n                    code,\n                    status,\n                }, res.data.error);\n            }\n        }\n        return {\n            message,\n            code: res.status,\n            status: res.statusText,\n        };\n    }\n}\nexports.GaxiosError = GaxiosError;\nfunction translateData(responseType, data) {\n    switch (responseType) {\n        case 'stream':\n            return data;\n        case 'json':\n            return JSON.parse(JSON.stringify(data));\n        case 'arraybuffer':\n            return JSON.parse(Buffer.from(data).toString('utf8'));\n        case 'blob':\n            return JSON.parse(data.text());\n        default:\n            return data;\n    }\n}\n/**\n * An experimental error redactor.\n *\n * @param config Config to potentially redact properties of\n * @param response Config to potentially redact properties of\n *\n * @experimental\n */\nfunction defaultErrorRedactor(data) {\n    const REDACT = '<<REDACTED> - See `errorRedactor` option in `gaxios` for configuration>.';\n    function redactHeaders(headers) {\n        if (!headers)\n            return;\n        headers.forEach((_, key) => {\n            // any casing of `Authentication`\n            // any casing of `Authorization`\n            // anything containing secret, such as 'client secret'\n            if (/^authentication$/i.test(key) ||\n                /^authorization$/i.test(key) ||\n                /secret/i.test(key))\n                headers.set(key, REDACT);\n        });\n    }\n    function redactString(obj, key) {\n        if (typeof obj === 'object' &&\n            obj !== null &&\n            typeof obj[key] === 'string') {\n            const text = obj[key];\n            if (/grant_type=/i.test(text) ||\n                /assertion=/i.test(text) ||\n                /secret/i.test(text)) {\n                obj[key] = REDACT;\n            }\n        }\n    }\n    function redactObject(obj) {\n        if (!obj || typeof obj !== 'object') {\n            return;\n        }\n        else if (obj instanceof FormData ||\n            obj instanceof URLSearchParams ||\n            // support `node-fetch` FormData/URLSearchParams\n            ('forEach' in obj && 'set' in obj)) {\n            obj.forEach((_, key) => {\n                if (['grant_type', 'assertion'].includes(key) || /secret/.test(key)) {\n                    obj.set(key, REDACT);\n                }\n            });\n        }\n        else {\n            if ('grant_type' in obj) {\n                obj['grant_type'] = REDACT;\n            }\n            if ('assertion' in obj) {\n                obj['assertion'] = REDACT;\n            }\n            if ('client_secret' in obj) {\n                obj['client_secret'] = REDACT;\n            }\n        }\n    }\n    if (data.config) {\n        redactHeaders(data.config.headers);\n        redactString(data.config, 'data');\n        redactObject(data.config.data);\n        redactString(data.config, 'body');\n        redactObject(data.config.body);\n        if (data.config.url.searchParams.has('token')) {\n            data.config.url.searchParams.set('token', REDACT);\n        }\n        if (data.config.url.searchParams.has('client_secret')) {\n            data.config.url.searchParams.set('client_secret', REDACT);\n        }\n    }\n    if (data.response) {\n        defaultErrorRedactor({ config: data.response.config });\n        redactHeaders(data.response.headers);\n        // workaround for `node-fetch`'s `.data` deprecation...\n        if (data.response.bodyUsed) {\n            redactString(data.response, 'data');\n            redactObject(data.response.data);\n        }\n    }\n    return data;\n}\n//# sourceMappingURL=common.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ2F4aW9zL2J1aWxkL2Nqcy9zcmMvY29tbW9uLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsbUJBQW1CLEdBQUcsMkJBQTJCO0FBQ2pELDRCQUE0QjtBQUM1QixpQ0FBaUMsbUJBQU8sQ0FBQyxvREFBUTtBQUNqRCxtQ0FBbUMsbUJBQU8sQ0FBQyxzRUFBWTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLDJCQUEyQixpQkFBaUIsU0FBUztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsYUFBYTtBQUNiLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IseUJBQXlCO0FBQ2pEO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixhQUFhO0FBQ2IsYUFBYTtBQUNiLGFBQWE7QUFDYixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLE9BQU87QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBLGlFQUFpRTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsOEJBQThCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaG9tZXdvcnRoLWFpLXByb3BlcnR5LXZhbHVhdGlvbi8uL25vZGVfbW9kdWxlcy9nYXhpb3MvYnVpbGQvY2pzL3NyYy9jb21tb24uanM/OTAwNCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTENcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5HYXhpb3NFcnJvciA9IGV4cG9ydHMuR0FYSU9TX0VSUk9SX1NZTUJPTCA9IHZvaWQgMDtcbmV4cG9ydHMuZGVmYXVsdEVycm9yUmVkYWN0b3IgPSBkZWZhdWx0RXJyb3JSZWRhY3RvcjtcbmNvbnN0IGV4dGVuZF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJleHRlbmRcIikpO1xuY29uc3QgdXRpbF9janNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi91dGlsLmNqc1wiKSk7XG5jb25zdCBwa2cgPSB1dGlsX2Nqc18xLmRlZmF1bHQucGtnO1xuLyoqXG4gKiBTdXBwb3J0IGBpbnN0YW5jZW9mYCBvcGVyYXRvciBmb3IgYEdheGlvc0Vycm9yYHMgaW4gZGlmZmVyZW50IHZlcnNpb25zIG9mIHRoaXMgbGlicmFyeS5cbiAqXG4gKiBAc2VlIHtAbGluayBHYXhpb3NFcnJvcltTeW1ib2wuaGFzSW5zdGFuY2VdfVxuICovXG5leHBvcnRzLkdBWElPU19FUlJPUl9TWU1CT0wgPSBTeW1ib2wuZm9yKGAke3BrZy5uYW1lfS1nYXhpb3MtZXJyb3JgKTtcbmNsYXNzIEdheGlvc0Vycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbmZpZztcbiAgICByZXNwb25zZTtcbiAgICAvKipcbiAgICAgKiBBbiBlcnJvciBjb2RlLlxuICAgICAqIENhbiBiZSBhIHN5c3RlbSBlcnJvciBjb2RlLCBET01FeGNlcHRpb24gZXJyb3IgbmFtZSwgb3IgYW55IGVycm9yJ3MgJ2NvZGUnIHByb3BlcnR5IHdoZXJlIGl0IGlzIGEgYHN0cmluZ2AuXG4gICAgICpcbiAgICAgKiBJdCBpcyBvbmx5IGEgYG51bWJlcmAgd2hlbiB0aGUgY2F1c2UgaXMgc291cmNlZCBmcm9tIGFuIEFQSS1sZXZlbCBlcnJvciAoQUlQLTE5MykuXG4gICAgICpcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL25vZGVqcy5vcmcvYXBpL2Vycm9ycy5odG1sI2Vycm9yY29kZSBlcnJvci5jb2RlfVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9ET01FeGNlcHRpb24jZXJyb3JfbmFtZXMgRE9NRXhjZXB0aW9uI2Vycm9yX25hbWVzfVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZ29vZ2xlLmFpcC5kZXYvMTkzI2h0dHAxMWpzb24tcmVwcmVzZW50YXRpb24gQUlQLTE5M31cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogJ0VDT05OUkVTRVQnXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICdUaW1lb3V0RXJyb3InXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIDUwMFxuICAgICAqL1xuICAgIGNvZGU7XG4gICAgLyoqXG4gICAgICogQW4gSFRUUCBTdGF0dXMgY29kZS5cbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvUmVzcG9uc2Uvc3RhdHVzIFJlc3BvbnNlI3N0YXR1c31cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogNTAwXG4gICAgICovXG4gICAgc3RhdHVzO1xuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIHVzZSB7QGxpbmsgR2F4aW9zRXJyb3IuY2F1c2V9IGluc3RlYWQuXG4gICAgICpcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9FcnJvci9jYXVzZSBFcnJvciNjYXVzZX1cbiAgICAgKlxuICAgICAqIEBwcml2YXRlUmVtYXJrc1xuICAgICAqXG4gICAgICogV2Ugd2lsbCB3YW50IHRvIHJlbW92ZSB0aGlzIHByb3BlcnR5IGxhdGVyIGFzIHRoZSBtb2Rlcm4gYGNhdXNlYCBwcm9wZXJ0eSBpcyBiZXR0ZXIgc3VpdGVkXG4gICAgICogZm9yIGRpc3BsYXlpbmcgYW5kIHJlbGF5aW5nIG5lc3RlZCBlcnJvcnMuIEtlZXBpbmcgdGhpcyBoZXJlIG1ha2VzIHRoZSByZXN1bHRpbmdcbiAgICAgKiBlcnJvciBsb2cgbGFyZ2VyIHRoYW4gaXQgbmVlZHMgdG8gYmUuXG4gICAgICpcbiAgICAgKi9cbiAgICBlcnJvcjtcbiAgICAvKipcbiAgICAgKiBTdXBwb3J0IGBpbnN0YW5jZW9mYCBvcGVyYXRvciBmb3IgYEdheGlvc0Vycm9yYCBhY3Jvc3MgYnVpbGRzL2R1cGxpY2F0ZWQgZmlsZXMuXG4gICAgICpcbiAgICAgKiBAc2VlIHtAbGluayBHQVhJT1NfRVJST1JfU1lNQk9MfVxuICAgICAqIEBzZWUge0BsaW5rIEdheGlvc0Vycm9yW1N5bWJvbC5oYXNJbnN0YW5jZV19XG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9UeXBlU2NyaXB0L2lzc3Vlcy8xMzk2NSNpc3N1ZWNvbW1lbnQtMjc4NTcwMjAwfVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzQ2NjE4ODUyL3JlcXVpcmUtYW5kLWluc3RhbmNlb2Z9XG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRnVuY3Rpb24vQEBoYXNJbnN0YW5jZSNyZXZlcnRpbmdfdG9fZGVmYXVsdF9pbnN0YW5jZW9mX2JlaGF2aW9yfVxuICAgICAqL1xuICAgIFtleHBvcnRzLkdBWElPU19FUlJPUl9TWU1CT0xdID0gcGtnLnZlcnNpb247XG4gICAgLyoqXG4gICAgICogU3VwcG9ydCBgaW5zdGFuY2VvZmAgb3BlcmF0b3IgZm9yIGBHYXhpb3NFcnJvcmAgYWNyb3NzIGJ1aWxkcy9kdXBsaWNhdGVkIGZpbGVzLlxuICAgICAqXG4gICAgICogQHNlZSB7QGxpbmsgR0FYSU9TX0VSUk9SX1NZTUJPTH1cbiAgICAgKiBAc2VlIHtAbGluayBHYXhpb3NFcnJvcltHQVhJT1NfRVJST1JfU1lNQk9MXX1cbiAgICAgKi9cbiAgICBzdGF0aWMgW1N5bWJvbC5oYXNJbnN0YW5jZV0oaW5zdGFuY2UpIHtcbiAgICAgICAgaWYgKGluc3RhbmNlICYmXG4gICAgICAgICAgICB0eXBlb2YgaW5zdGFuY2UgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICBleHBvcnRzLkdBWElPU19FUlJPUl9TWU1CT0wgaW4gaW5zdGFuY2UgJiZcbiAgICAgICAgICAgIGluc3RhbmNlW2V4cG9ydHMuR0FYSU9TX0VSUk9SX1NZTUJPTF0gPT09IHBrZy52ZXJzaW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBmYWxsYmFjayB0byBuYXRpdmVcbiAgICAgICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZVtTeW1ib2wuaGFzSW5zdGFuY2VdLmNhbGwoR2F4aW9zRXJyb3IsIGluc3RhbmNlKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgY29uZmlnLCByZXNwb25zZSwgY2F1c2UpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSwgeyBjYXVzZSB9KTtcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgICAgIHRoaXMucmVzcG9uc2UgPSByZXNwb25zZTtcbiAgICAgICAgdGhpcy5lcnJvciA9IGNhdXNlIGluc3RhbmNlb2YgRXJyb3IgPyBjYXVzZSA6IHVuZGVmaW5lZDtcbiAgICAgICAgLy8gZGVlcC1jb3B5IGNvbmZpZyBhcyB3ZSBkbyBub3Qgd2FudCB0byBtdXRhdGVcbiAgICAgICAgLy8gdGhlIGV4aXN0aW5nIGNvbmZpZyBmb3IgZnV0dXJlIHJldHJpZXMvdXNlXG4gICAgICAgIHRoaXMuY29uZmlnID0gKDAsIGV4dGVuZF8xLmRlZmF1bHQpKHRydWUsIHt9LCBjb25maWcpO1xuICAgICAgICBpZiAodGhpcy5yZXNwb25zZSkge1xuICAgICAgICAgICAgdGhpcy5yZXNwb25zZS5jb25maWcgPSAoMCwgZXh0ZW5kXzEuZGVmYXVsdCkodHJ1ZSwge30sIHRoaXMucmVzcG9uc2UuY29uZmlnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5yZXNwb25zZSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3BvbnNlLmRhdGEgPSB0cmFuc2xhdGVEYXRhKHRoaXMuY29uZmlnLnJlc3BvbnNlVHlwZSwgXG4gICAgICAgICAgICAgICAgLy8gd29ya2Fyb3VuZCBmb3IgYG5vZGUtZmV0Y2hgJ3MgYC5kYXRhYCBkZXByZWNhdGlvbi4uLlxuICAgICAgICAgICAgICAgIHRoaXMucmVzcG9uc2U/LmJvZHlVc2VkID8gdGhpcy5yZXNwb25zZT8uZGF0YSA6IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCB7XG4gICAgICAgICAgICAgICAgLy8gYmVzdCBlZmZvcnQgLSBkb24ndCB0aHJvdyBhbiBlcnJvciB3aXRoaW4gYW4gZXJyb3JcbiAgICAgICAgICAgICAgICAvLyB3ZSBjb3VsZCBzZXQgYHRoaXMucmVzcG9uc2UuY29uZmlnLnJlc3BvbnNlVHlwZSA9ICd1bmtub3duJ2AsIGJ1dFxuICAgICAgICAgICAgICAgIC8vIHRoYXQgd291bGQgbXV0YXRlIGZ1dHVyZSBjYWxscyB3aXRoIHRoaXMgY29uZmlnIG9iamVjdC5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc3RhdHVzID0gdGhpcy5yZXNwb25zZS5zdGF0dXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNhdXNlIGluc3RhbmNlb2YgRE9NRXhjZXB0aW9uKSB7XG4gICAgICAgICAgICAvLyBUaGUgRE9NRXhjZXB0aW9uJ3MgZXF1aXZhbGVudCB0byBjb2RlIGlzIGl0cyBuYW1lXG4gICAgICAgICAgICAvLyBFLmcuOiBuYW1lID0gYFRpbWVvdXRFcnJvcmAsIGNvZGUgPSBudW1iZXJcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9ET01FeGNlcHRpb24vbmFtZVxuICAgICAgICAgICAgdGhpcy5jb2RlID0gY2F1c2UubmFtZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjYXVzZSAmJlxuICAgICAgICAgICAgdHlwZW9mIGNhdXNlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgJ2NvZGUnIGluIGNhdXNlICYmXG4gICAgICAgICAgICAodHlwZW9mIGNhdXNlLmNvZGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBjYXVzZS5jb2RlID09PSAnbnVtYmVyJykpIHtcbiAgICAgICAgICAgIHRoaXMuY29kZSA9IGNhdXNlLmNvZGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQW4gQUlQLTE5MyBjb25mb3JtaW5nIGVycm9yIGV4dHJhY3Rvci5cbiAgICAgKlxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZ29vZ2xlLmFpcC5kZXYvMTkzI2h0dHAxMWpzb24tcmVwcmVzZW50YXRpb24gQUlQLTE5M31cbiAgICAgKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqIEBleHBpcmVtZW50YWxcbiAgICAgKlxuICAgICAqIEBwYXJhbSByZXMgdGhlIHJlc3BvbnNlIG9iamVjdFxuICAgICAqIEByZXR1cm5zIHRoZSBleHRyYWN0ZWQgZXJyb3IgaW5mb3JtYXRpb25cbiAgICAgKi9cbiAgICBzdGF0aWMgZXh0cmFjdEFQSUVycm9yRnJvbVJlc3BvbnNlKHJlcywgZGVmYXVsdEVycm9yTWVzc2FnZSA9ICdUaGUgcmVxdWVzdCBmYWlsZWQnKSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gZGVmYXVsdEVycm9yTWVzc2FnZTtcbiAgICAgICAgLy8gVXNlIHJlcy5kYXRhIGFzIHRoZSBlcnJvciBtZXNzYWdlXG4gICAgICAgIGlmICh0eXBlb2YgcmVzLmRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBtZXNzYWdlID0gcmVzLmRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlcy5kYXRhICYmXG4gICAgICAgICAgICB0eXBlb2YgcmVzLmRhdGEgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICAnZXJyb3InIGluIHJlcy5kYXRhICYmXG4gICAgICAgICAgICByZXMuZGF0YS5lcnJvciAmJlxuICAgICAgICAgICAgIXJlcy5vaykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiByZXMuZGF0YS5lcnJvciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiByZXMuZGF0YS5lcnJvcixcbiAgICAgICAgICAgICAgICAgICAgY29kZTogcmVzLnN0YXR1cyxcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiByZXMuc3RhdHVzVGV4dCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiByZXMuZGF0YS5lcnJvciA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAvLyBleHRyYWN0IHN0YXR1cyBmcm9tIGRhdGEubWVzc2FnZVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPVxuICAgICAgICAgICAgICAgICAgICAnbWVzc2FnZScgaW4gcmVzLmRhdGEuZXJyb3IgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiByZXMuZGF0YS5lcnJvci5tZXNzYWdlID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgICAgICAgICAgICAgPyByZXMuZGF0YS5lcnJvci5tZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgICAgICA6IG1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgLy8gZXh0cmFjdCBzdGF0dXMgZnJvbSBkYXRhLmVycm9yXG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhdHVzID0gJ3N0YXR1cycgaW4gcmVzLmRhdGEuZXJyb3IgJiZcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHJlcy5kYXRhLmVycm9yLnN0YXR1cyA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgICAgICAgICAgPyByZXMuZGF0YS5lcnJvci5zdGF0dXNcbiAgICAgICAgICAgICAgICAgICAgOiByZXMuc3RhdHVzVGV4dDtcbiAgICAgICAgICAgICAgICAvLyBleHRyYWN0IGNvZGUgZnJvbSBkYXRhLmVycm9yXG4gICAgICAgICAgICAgICAgY29uc3QgY29kZSA9ICdjb2RlJyBpbiByZXMuZGF0YS5lcnJvciAmJiB0eXBlb2YgcmVzLmRhdGEuZXJyb3IuY29kZSA9PT0gJ251bWJlcidcbiAgICAgICAgICAgICAgICAgICAgPyByZXMuZGF0YS5lcnJvci5jb2RlXG4gICAgICAgICAgICAgICAgICAgIDogcmVzLnN0YXR1cztcbiAgICAgICAgICAgICAgICBpZiAoJ2Vycm9ycycgaW4gcmVzLmRhdGEuZXJyb3IgJiZcbiAgICAgICAgICAgICAgICAgICAgQXJyYXkuaXNBcnJheShyZXMuZGF0YS5lcnJvci5lcnJvcnMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBlIG9mIHJlcy5kYXRhLmVycm9yLmVycm9ycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdtZXNzYWdlJyBpbiBlICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGUubWVzc2FnZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2VzLnB1c2goZS5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBlcnJvck1lc3NhZ2VzLmpvaW4oJ1xcbicpIHx8IG1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzLFxuICAgICAgICAgICAgICAgICAgICB9LCByZXMuZGF0YS5lcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgY29kZSxcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLFxuICAgICAgICAgICAgICAgIH0sIHJlcy5kYXRhLmVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgICAgIGNvZGU6IHJlcy5zdGF0dXMsXG4gICAgICAgICAgICBzdGF0dXM6IHJlcy5zdGF0dXNUZXh0LFxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuR2F4aW9zRXJyb3IgPSBHYXhpb3NFcnJvcjtcbmZ1bmN0aW9uIHRyYW5zbGF0ZURhdGEocmVzcG9uc2VUeXBlLCBkYXRhKSB7XG4gICAgc3dpdGNoIChyZXNwb25zZVR5cGUpIHtcbiAgICAgICAgY2FzZSAnc3RyZWFtJzpcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICBjYXNlICdqc29uJzpcbiAgICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGRhdGEpKTtcbiAgICAgICAgY2FzZSAnYXJyYXlidWZmZXInOlxuICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoQnVmZmVyLmZyb20oZGF0YSkudG9TdHJpbmcoJ3V0ZjgnKSk7XG4gICAgICAgIGNhc2UgJ2Jsb2InOlxuICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoZGF0YS50ZXh0KCkpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxufVxuLyoqXG4gKiBBbiBleHBlcmltZW50YWwgZXJyb3IgcmVkYWN0b3IuXG4gKlxuICogQHBhcmFtIGNvbmZpZyBDb25maWcgdG8gcG90ZW50aWFsbHkgcmVkYWN0IHByb3BlcnRpZXMgb2ZcbiAqIEBwYXJhbSByZXNwb25zZSBDb25maWcgdG8gcG90ZW50aWFsbHkgcmVkYWN0IHByb3BlcnRpZXMgb2ZcbiAqXG4gKiBAZXhwZXJpbWVudGFsXG4gKi9cbmZ1bmN0aW9uIGRlZmF1bHRFcnJvclJlZGFjdG9yKGRhdGEpIHtcbiAgICBjb25zdCBSRURBQ1QgPSAnPDxSRURBQ1RFRD4gLSBTZWUgYGVycm9yUmVkYWN0b3JgIG9wdGlvbiBpbiBgZ2F4aW9zYCBmb3IgY29uZmlndXJhdGlvbj4uJztcbiAgICBmdW5jdGlvbiByZWRhY3RIZWFkZXJzKGhlYWRlcnMpIHtcbiAgICAgICAgaWYgKCFoZWFkZXJzKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBoZWFkZXJzLmZvckVhY2goKF8sIGtleSkgPT4ge1xuICAgICAgICAgICAgLy8gYW55IGNhc2luZyBvZiBgQXV0aGVudGljYXRpb25gXG4gICAgICAgICAgICAvLyBhbnkgY2FzaW5nIG9mIGBBdXRob3JpemF0aW9uYFxuICAgICAgICAgICAgLy8gYW55dGhpbmcgY29udGFpbmluZyBzZWNyZXQsIHN1Y2ggYXMgJ2NsaWVudCBzZWNyZXQnXG4gICAgICAgICAgICBpZiAoL15hdXRoZW50aWNhdGlvbiQvaS50ZXN0KGtleSkgfHxcbiAgICAgICAgICAgICAgICAvXmF1dGhvcml6YXRpb24kL2kudGVzdChrZXkpIHx8XG4gICAgICAgICAgICAgICAgL3NlY3JldC9pLnRlc3Qoa2V5KSlcbiAgICAgICAgICAgICAgICBoZWFkZXJzLnNldChrZXksIFJFREFDVCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZWRhY3RTdHJpbmcob2JqLCBrZXkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICBvYmogIT09IG51bGwgJiZcbiAgICAgICAgICAgIHR5cGVvZiBvYmpba2V5XSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNvbnN0IHRleHQgPSBvYmpba2V5XTtcbiAgICAgICAgICAgIGlmICgvZ3JhbnRfdHlwZT0vaS50ZXN0KHRleHQpIHx8XG4gICAgICAgICAgICAgICAgL2Fzc2VydGlvbj0vaS50ZXN0KHRleHQpIHx8XG4gICAgICAgICAgICAgICAgL3NlY3JldC9pLnRlc3QodGV4dCkpIHtcbiAgICAgICAgICAgICAgICBvYmpba2V5XSA9IFJFREFDVDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiByZWRhY3RPYmplY3Qob2JqKSB7XG4gICAgICAgIGlmICghb2JqIHx8IHR5cGVvZiBvYmogIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgRm9ybURhdGEgfHxcbiAgICAgICAgICAgIG9iaiBpbnN0YW5jZW9mIFVSTFNlYXJjaFBhcmFtcyB8fFxuICAgICAgICAgICAgLy8gc3VwcG9ydCBgbm9kZS1mZXRjaGAgRm9ybURhdGEvVVJMU2VhcmNoUGFyYW1zXG4gICAgICAgICAgICAoJ2ZvckVhY2gnIGluIG9iaiAmJiAnc2V0JyBpbiBvYmopKSB7XG4gICAgICAgICAgICBvYmouZm9yRWFjaCgoXywga2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKFsnZ3JhbnRfdHlwZScsICdhc3NlcnRpb24nXS5pbmNsdWRlcyhrZXkpIHx8IC9zZWNyZXQvLnRlc3Qoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBvYmouc2V0KGtleSwgUkVEQUNUKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICgnZ3JhbnRfdHlwZScgaW4gb2JqKSB7XG4gICAgICAgICAgICAgICAgb2JqWydncmFudF90eXBlJ10gPSBSRURBQ1Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoJ2Fzc2VydGlvbicgaW4gb2JqKSB7XG4gICAgICAgICAgICAgICAgb2JqWydhc3NlcnRpb24nXSA9IFJFREFDVDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgnY2xpZW50X3NlY3JldCcgaW4gb2JqKSB7XG4gICAgICAgICAgICAgICAgb2JqWydjbGllbnRfc2VjcmV0J10gPSBSRURBQ1Q7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGRhdGEuY29uZmlnKSB7XG4gICAgICAgIHJlZGFjdEhlYWRlcnMoZGF0YS5jb25maWcuaGVhZGVycyk7XG4gICAgICAgIHJlZGFjdFN0cmluZyhkYXRhLmNvbmZpZywgJ2RhdGEnKTtcbiAgICAgICAgcmVkYWN0T2JqZWN0KGRhdGEuY29uZmlnLmRhdGEpO1xuICAgICAgICByZWRhY3RTdHJpbmcoZGF0YS5jb25maWcsICdib2R5Jyk7XG4gICAgICAgIHJlZGFjdE9iamVjdChkYXRhLmNvbmZpZy5ib2R5KTtcbiAgICAgICAgaWYgKGRhdGEuY29uZmlnLnVybC5zZWFyY2hQYXJhbXMuaGFzKCd0b2tlbicpKSB7XG4gICAgICAgICAgICBkYXRhLmNvbmZpZy51cmwuc2VhcmNoUGFyYW1zLnNldCgndG9rZW4nLCBSRURBQ1QpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLmNvbmZpZy51cmwuc2VhcmNoUGFyYW1zLmhhcygnY2xpZW50X3NlY3JldCcpKSB7XG4gICAgICAgICAgICBkYXRhLmNvbmZpZy51cmwuc2VhcmNoUGFyYW1zLnNldCgnY2xpZW50X3NlY3JldCcsIFJFREFDVCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGRhdGEucmVzcG9uc2UpIHtcbiAgICAgICAgZGVmYXVsdEVycm9yUmVkYWN0b3IoeyBjb25maWc6IGRhdGEucmVzcG9uc2UuY29uZmlnIH0pO1xuICAgICAgICByZWRhY3RIZWFkZXJzKGRhdGEucmVzcG9uc2UuaGVhZGVycyk7XG4gICAgICAgIC8vIHdvcmthcm91bmQgZm9yIGBub2RlLWZldGNoYCdzIGAuZGF0YWAgZGVwcmVjYXRpb24uLi5cbiAgICAgICAgaWYgKGRhdGEucmVzcG9uc2UuYm9keVVzZWQpIHtcbiAgICAgICAgICAgIHJlZGFjdFN0cmluZyhkYXRhLnJlc3BvbnNlLCAnZGF0YScpO1xuICAgICAgICAgICAgcmVkYWN0T2JqZWN0KGRhdGEucmVzcG9uc2UuZGF0YSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb21tb24uanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/gaxios/build/cjs/src/common.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/gaxios/build/cjs/src/gaxios.js":
/*!*****************************************************!*\
  !*** ./node_modules/gaxios/build/cjs/src/gaxios.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n// Copyright 2018 Google LLC\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nvar _a;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Gaxios = void 0;\nconst extend_1 = __importDefault(__webpack_require__(/*! extend */ \"(rsc)/./node_modules/extend/index.js\"));\nconst https_1 = __webpack_require__(/*! https */ \"https\");\nconst common_js_1 = __webpack_require__(/*! ./common.js */ \"(rsc)/./node_modules/gaxios/build/cjs/src/common.js\");\nconst retry_js_1 = __webpack_require__(/*! ./retry.js */ \"(rsc)/./node_modules/gaxios/build/cjs/src/retry.js\");\nconst stream_1 = __webpack_require__(/*! stream */ \"stream\");\nconst interceptor_js_1 = __webpack_require__(/*! ./interceptor.js */ \"(rsc)/./node_modules/gaxios/build/cjs/src/interceptor.js\");\nconst randomUUID = async () => globalThis.crypto?.randomUUID() || (await Promise.resolve(/*! import() */).then(__webpack_require__.t.bind(__webpack_require__, /*! crypto */ \"crypto\", 23))).randomUUID();\nclass Gaxios {\n    agentCache = new Map();\n    /**\n     * Default HTTP options that will be used for every HTTP request.\n     */\n    defaults;\n    /**\n     * Interceptors\n     */\n    interceptors;\n    /**\n     * The Gaxios class is responsible for making HTTP requests.\n     * @param defaults The default set of options to be used for this instance.\n     */\n    constructor(defaults) {\n        this.defaults = defaults || {};\n        this.interceptors = {\n            request: new interceptor_js_1.GaxiosInterceptorManager(),\n            response: new interceptor_js_1.GaxiosInterceptorManager(),\n        };\n    }\n    /**\n     * A {@link fetch `fetch`} compliant API for {@link Gaxios}.\n     *\n     * @remarks\n     *\n     * This is useful as a drop-in replacement for `fetch` API usage.\n     *\n     * @example\n     *\n     * ```ts\n     * const gaxios = new Gaxios();\n     * const myFetch: typeof fetch = (...args) => gaxios.fetch(...args);\n     * await myFetch('https://example.com');\n     * ```\n     *\n     * @param args `fetch` API or `Gaxios#request` parameters\n     * @returns the {@link Response} with Gaxios-added properties\n     */\n    fetch(...args) {\n        // Up to 2 parameters in either overload\n        const input = args[0];\n        const init = args[1];\n        let url = undefined;\n        const headers = new Headers();\n        // prepare URL\n        if (typeof input === 'string') {\n            url = new URL(input);\n        }\n        else if (input instanceof URL) {\n            url = input;\n        }\n        else if (input && input.url) {\n            url = new URL(input.url);\n        }\n        // prepare headers\n        if (input && typeof input === 'object' && 'headers' in input) {\n            _a.mergeHeaders(headers, input.headers);\n        }\n        if (init) {\n            _a.mergeHeaders(headers, new Headers(init.headers));\n        }\n        // prepare request\n        if (typeof input === 'object' && !(input instanceof URL)) {\n            // input must have been a non-URL object\n            return this.request({ ...init, ...input, headers, url });\n        }\n        else {\n            // input must have been a string or URL\n            return this.request({ ...init, headers, url });\n        }\n    }\n    /**\n     * Perform an HTTP request with the given options.\n     * @param opts Set of HTTP options that will be used for this HTTP request.\n     */\n    async request(opts = {}) {\n        let prepared = await this.#prepareRequest(opts);\n        prepared = await this.#applyRequestInterceptors(prepared);\n        return this.#applyResponseInterceptors(this._request(prepared));\n    }\n    async _defaultAdapter(config) {\n        const fetchImpl = config.fetchImplementation ||\n            this.defaults.fetchImplementation ||\n            (await _a.#getFetch());\n        // node-fetch v3 warns when `data` is present\n        // https://github.com/node-fetch/node-fetch/issues/1000\n        const preparedOpts = { ...config };\n        delete preparedOpts.data;\n        const res = (await fetchImpl(config.url, preparedOpts));\n        const data = await this.getResponseData(config, res);\n        if (!Object.getOwnPropertyDescriptor(res, 'data')?.configurable) {\n            // Work-around for `node-fetch` v3 as accessing `data` would otherwise throw\n            Object.defineProperties(res, {\n                data: {\n                    configurable: true,\n                    writable: true,\n                    enumerable: true,\n                    value: data,\n                },\n            });\n        }\n        // Keep object as an instance of `Response`\n        return Object.assign(res, { config, data });\n    }\n    /**\n     * Internal, retryable version of the `request` method.\n     * @param opts Set of HTTP options that will be used for this HTTP request.\n     */\n    async _request(opts) {\n        try {\n            let translatedResponse;\n            if (opts.adapter) {\n                translatedResponse = await opts.adapter(opts, this._defaultAdapter.bind(this));\n            }\n            else {\n                translatedResponse = await this._defaultAdapter(opts);\n            }\n            if (!opts.validateStatus(translatedResponse.status)) {\n                if (opts.responseType === 'stream') {\n                    const response = [];\n                    for await (const chunk of translatedResponse.data) {\n                        response.push(chunk);\n                    }\n                    translatedResponse.data = response.toString();\n                }\n                const errorInfo = common_js_1.GaxiosError.extractAPIErrorFromResponse(translatedResponse, `Request failed with status code ${translatedResponse.status}`);\n                throw new common_js_1.GaxiosError(errorInfo?.message, opts, translatedResponse, errorInfo);\n            }\n            return translatedResponse;\n        }\n        catch (e) {\n            let err;\n            if (e instanceof common_js_1.GaxiosError) {\n                err = e;\n            }\n            else if (e instanceof Error) {\n                err = new common_js_1.GaxiosError(e.message, opts, undefined, e);\n            }\n            else {\n                err = new common_js_1.GaxiosError('Unexpected Gaxios Error', opts, undefined, e);\n            }\n            const { shouldRetry, config } = await (0, retry_js_1.getRetryConfig)(err);\n            if (shouldRetry && config) {\n                err.config.retryConfig.currentRetryAttempt =\n                    config.retryConfig.currentRetryAttempt;\n                // The error's config could be redacted - therefore we only want to\n                // copy the retry state over to the existing config\n                opts.retryConfig = err.config?.retryConfig;\n                // re-prepare timeout for the next request\n                this.#appendTimeoutToSignal(opts);\n                return this._request(opts);\n            }\n            if (opts.errorRedactor) {\n                opts.errorRedactor(err);\n            }\n            throw err;\n        }\n    }\n    async getResponseData(opts, res) {\n        if (opts.maxContentLength &&\n            res.headers.has('content-length') &&\n            opts.maxContentLength <\n                Number.parseInt(res.headers?.get('content-length') || '')) {\n            throw new common_js_1.GaxiosError(\"Response's `Content-Length` is over the limit.\", opts, Object.assign(res, { config: opts }));\n        }\n        switch (opts.responseType) {\n            case 'stream':\n                return res.body;\n            case 'json':\n                return res.json();\n            case 'arraybuffer':\n                return res.arrayBuffer();\n            case 'blob':\n                return res.blob();\n            case 'text':\n                return res.text();\n            default:\n                return this.getResponseDataFromContentType(res);\n        }\n    }\n    #urlMayUseProxy(url, noProxy = []) {\n        const candidate = new URL(url);\n        const noProxyList = [...noProxy];\n        const noProxyEnvList = (process.env.NO_PROXY ?? process.env.no_proxy)?.split(',') || [];\n        for (const rule of noProxyEnvList) {\n            noProxyList.push(rule.trim());\n        }\n        for (const rule of noProxyList) {\n            // Match regex\n            if (rule instanceof RegExp) {\n                if (rule.test(candidate.toString())) {\n                    return false;\n                }\n            }\n            // Match URL\n            else if (rule instanceof URL) {\n                if (rule.origin === candidate.origin) {\n                    return false;\n                }\n            }\n            // Match string regex\n            else if (rule.startsWith('*.') || rule.startsWith('.')) {\n                const cleanedRule = rule.replace(/^\\*\\./, '.');\n                if (candidate.hostname.endsWith(cleanedRule)) {\n                    return false;\n                }\n            }\n            // Basic string match\n            else if (rule === candidate.origin ||\n                rule === candidate.hostname ||\n                rule === candidate.href) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Applies the request interceptors. The request interceptors are applied after the\n     * call to prepareRequest is completed.\n     *\n     * @param {GaxiosOptionsPrepared} options The current set of options.\n     *\n     * @returns {Promise<GaxiosOptionsPrepared>} Promise that resolves to the set of options or response after interceptors are applied.\n     */\n    async #applyRequestInterceptors(options) {\n        let promiseChain = Promise.resolve(options);\n        for (const interceptor of this.interceptors.request.values()) {\n            if (interceptor) {\n                promiseChain = promiseChain.then(interceptor.resolved, interceptor.rejected);\n            }\n        }\n        return promiseChain;\n    }\n    /**\n     * Applies the response interceptors. The response interceptors are applied after the\n     * call to request is made.\n     *\n     * @param {GaxiosOptionsPrepared} options The current set of options.\n     *\n     * @returns {Promise<GaxiosOptionsPrepared>} Promise that resolves to the set of options or response after interceptors are applied.\n     */\n    async #applyResponseInterceptors(response) {\n        let promiseChain = Promise.resolve(response);\n        for (const interceptor of this.interceptors.response.values()) {\n            if (interceptor) {\n                promiseChain = promiseChain.then(interceptor.resolved, interceptor.rejected);\n            }\n        }\n        return promiseChain;\n    }\n    /**\n     * Validates the options, merges them with defaults, and prepare request.\n     *\n     * @param options The original options passed from the client.\n     * @returns Prepared options, ready to make a request\n     */\n    async #prepareRequest(options) {\n        // Prepare Headers - copy in order to not mutate the original objects\n        const preparedHeaders = new Headers(this.defaults.headers);\n        _a.mergeHeaders(preparedHeaders, options.headers);\n        // Merge options\n        const opts = (0, extend_1.default)(true, {}, this.defaults, options);\n        if (!opts.url) {\n            throw new Error('URL is required.');\n        }\n        if (opts.baseURL) {\n            opts.url = new URL(opts.url, opts.baseURL);\n        }\n        // don't modify the properties of a default or provided URL\n        opts.url = new URL(opts.url);\n        if (opts.params) {\n            if (opts.paramsSerializer) {\n                let additionalQueryParams = opts.paramsSerializer(opts.params);\n                if (additionalQueryParams.startsWith('?')) {\n                    additionalQueryParams = additionalQueryParams.slice(1);\n                }\n                const prefix = opts.url.toString().includes('?') ? '&' : '?';\n                opts.url = opts.url + prefix + additionalQueryParams;\n            }\n            else {\n                const url = opts.url instanceof URL ? opts.url : new URL(opts.url);\n                for (const [key, value] of new URLSearchParams(opts.params)) {\n                    url.searchParams.append(key, value);\n                }\n                opts.url = url;\n            }\n        }\n        if (typeof options.maxContentLength === 'number') {\n            opts.size = options.maxContentLength;\n        }\n        if (typeof options.maxRedirects === 'number') {\n            opts.follow = options.maxRedirects;\n        }\n        const shouldDirectlyPassData = typeof opts.data === 'string' ||\n            opts.data instanceof ArrayBuffer ||\n            opts.data instanceof Blob ||\n            // Node 18 does not have a global `File` object\n            (globalThis.File && opts.data instanceof File) ||\n            opts.data instanceof FormData ||\n            opts.data instanceof stream_1.Readable ||\n            opts.data instanceof ReadableStream ||\n            opts.data instanceof String ||\n            opts.data instanceof URLSearchParams ||\n            ArrayBuffer.isView(opts.data) || // `Buffer` (Node.js), `DataView`, `TypedArray`\n            /**\n             * @deprecated `node-fetch` or another third-party's request types\n             */\n            ['Blob', 'File', 'FormData'].includes(opts.data?.constructor?.name || '');\n        if (opts.multipart?.length) {\n            const boundary = await randomUUID();\n            preparedHeaders.set('content-type', `multipart/related; boundary=${boundary}`);\n            opts.body = stream_1.Readable.from(this.getMultipartRequest(opts.multipart, boundary));\n        }\n        else if (shouldDirectlyPassData) {\n            opts.body = opts.data;\n        }\n        else if (typeof opts.data === 'object') {\n            if (preparedHeaders.get('Content-Type') ===\n                'application/x-www-form-urlencoded') {\n                // If www-form-urlencoded content type has been set, but data is\n                // provided as an object, serialize the content\n                opts.body = opts.paramsSerializer\n                    ? opts.paramsSerializer(opts.data)\n                    : new URLSearchParams(opts.data);\n            }\n            else {\n                if (!preparedHeaders.has('content-type')) {\n                    preparedHeaders.set('content-type', 'application/json');\n                }\n                opts.body = JSON.stringify(opts.data);\n            }\n        }\n        else if (opts.data) {\n            opts.body = opts.data;\n        }\n        opts.validateStatus = opts.validateStatus || this.validateStatus;\n        opts.responseType = opts.responseType || 'unknown';\n        if (!preparedHeaders.has('accept') && opts.responseType === 'json') {\n            preparedHeaders.set('accept', 'application/json');\n        }\n        const proxy = opts.proxy ||\n            process?.env?.HTTPS_PROXY ||\n            process?.env?.https_proxy ||\n            process?.env?.HTTP_PROXY ||\n            process?.env?.http_proxy;\n        if (opts.agent) {\n            // don't do any of the following options - use the user-provided agent.\n        }\n        else if (proxy && this.#urlMayUseProxy(opts.url, opts.noProxy)) {\n            const HttpsProxyAgent = await _a.#getProxyAgent();\n            if (this.agentCache.has(proxy)) {\n                opts.agent = this.agentCache.get(proxy);\n            }\n            else {\n                opts.agent = new HttpsProxyAgent(proxy, {\n                    cert: opts.cert,\n                    key: opts.key,\n                });\n                this.agentCache.set(proxy, opts.agent);\n            }\n        }\n        else if (opts.cert && opts.key) {\n            // Configure client for mTLS\n            if (this.agentCache.has(opts.key)) {\n                opts.agent = this.agentCache.get(opts.key);\n            }\n            else {\n                opts.agent = new https_1.Agent({\n                    cert: opts.cert,\n                    key: opts.key,\n                });\n                this.agentCache.set(opts.key, opts.agent);\n            }\n        }\n        if (typeof opts.errorRedactor !== 'function' &&\n            opts.errorRedactor !== false) {\n            opts.errorRedactor = common_js_1.defaultErrorRedactor;\n        }\n        if (opts.body && !('duplex' in opts)) {\n            /**\n             * required for Node.js and the type isn't available today\n             * @link https://github.com/nodejs/node/issues/46221\n             * @link https://github.com/microsoft/TypeScript-DOM-lib-generator/issues/1483\n             */\n            opts.duplex = 'half';\n        }\n        this.#appendTimeoutToSignal(opts);\n        return Object.assign(opts, {\n            headers: preparedHeaders,\n            url: opts.url instanceof URL ? opts.url : new URL(opts.url),\n        });\n    }\n    #appendTimeoutToSignal(opts) {\n        if (opts.timeout) {\n            const timeoutSignal = AbortSignal.timeout(opts.timeout);\n            if (opts.signal && !opts.signal.aborted) {\n                opts.signal = AbortSignal.any([opts.signal, timeoutSignal]);\n            }\n            else {\n                opts.signal = timeoutSignal;\n            }\n        }\n    }\n    /**\n     * By default, throw for any non-2xx status code\n     * @param status status code from the HTTP response\n     */\n    validateStatus(status) {\n        return status >= 200 && status < 300;\n    }\n    /**\n     * Attempts to parse a response by looking at the Content-Type header.\n     * @param {Response} response the HTTP response.\n     * @returns a promise that resolves to the response data.\n     */\n    async getResponseDataFromContentType(response) {\n        let contentType = response.headers.get('Content-Type');\n        if (contentType === null) {\n            // Maintain existing functionality by calling text()\n            return response.text();\n        }\n        contentType = contentType.toLowerCase();\n        if (contentType.includes('application/json')) {\n            let data = await response.text();\n            try {\n                data = JSON.parse(data);\n            }\n            catch {\n                // continue\n            }\n            return data;\n        }\n        else if (contentType.match(/^text\\//)) {\n            return response.text();\n        }\n        else {\n            // If the content type is something not easily handled, just return the raw data (blob)\n            return response.blob();\n        }\n    }\n    /**\n     * Creates an async generator that yields the pieces of a multipart/related request body.\n     * This implementation follows the spec: https://www.ietf.org/rfc/rfc2387.txt. However, recursive\n     * multipart/related requests are not currently supported.\n     *\n     * @param {GaxioMultipartOptions[]} multipartOptions the pieces to turn into a multipart/related body.\n     * @param {string} boundary the boundary string to be placed between each part.\n     */\n    async *getMultipartRequest(multipartOptions, boundary) {\n        const finale = `--${boundary}--`;\n        for (const currentPart of multipartOptions) {\n            const partContentType = currentPart.headers.get('Content-Type') || 'application/octet-stream';\n            const preamble = `--${boundary}\\r\\nContent-Type: ${partContentType}\\r\\n\\r\\n`;\n            yield preamble;\n            if (typeof currentPart.content === 'string') {\n                yield currentPart.content;\n            }\n            else {\n                yield* currentPart.content;\n            }\n            yield '\\r\\n';\n        }\n        yield finale;\n    }\n    /**\n     * A cache for the lazily-loaded proxy agent.\n     *\n     * Should use {@link Gaxios[#getProxyAgent]} to retrieve.\n     */\n    // using `import` to dynamically import the types here\n    static #proxyAgent;\n    /**\n     * A cache for the lazily-loaded fetch library.\n     *\n     * Should use {@link Gaxios[#getFetch]} to retrieve.\n     */\n    //\n    static #fetch;\n    /**\n     * Imports, caches, and returns a proxy agent - if not already imported\n     *\n     * @returns A proxy agent\n     */\n    static async #getProxyAgent() {\n        this.#proxyAgent ||= (await Promise.all(/*! import() */[__webpack_require__.e(\"vendor-chunks/debug\"), __webpack_require__.e(\"vendor-chunks/https-proxy-agent\"), __webpack_require__.e(\"vendor-chunks/agent-base\"), __webpack_require__.e(\"vendor-chunks/supports-color\"), __webpack_require__.e(\"vendor-chunks/ms\"), __webpack_require__.e(\"vendor-chunks/has-flag\")]).then(__webpack_require__.t.bind(__webpack_require__, /*! https-proxy-agent */ \"(rsc)/./node_modules/https-proxy-agent/dist/index.js\", 23))).HttpsProxyAgent;\n        return this.#proxyAgent;\n    }\n    static async #getFetch() {\n        const hasWindow = typeof window !== 'undefined' && !!window;\n        this.#fetch ||= hasWindow\n            ? window.fetch\n            : (await Promise.all(/*! import() */[__webpack_require__.e(\"vendor-chunks/node-fetch\"), __webpack_require__.e(\"vendor-chunks/fetch-blob\"), __webpack_require__.e(\"vendor-chunks/formdata-polyfill\"), __webpack_require__.e(\"vendor-chunks/data-uri-to-buffer\"), __webpack_require__.e(\"vendor-chunks/web-streams-polyfill\"), __webpack_require__.e(\"vendor-chunks/node-domexception\")]).then(__webpack_require__.bind(__webpack_require__, /*! node-fetch */ \"(rsc)/./node_modules/node-fetch/src/index.js\"))).default;\n        return this.#fetch;\n    }\n    /**\n     * Merges headers.\n     * If the base headers do not exist a new `Headers` object will be returned.\n     *\n     * @remarks\n     *\n     * Using this utility can be helpful when the headers are not known to exist:\n     * - if they exist as `Headers`, that instance will be used\n     *   - it improves performance and allows users to use their existing references to their `Headers`\n     * - if they exist in another form (`HeadersInit`), they will be used to create a new `Headers` object\n     * - if the base headers do not exist a new `Headers` object will be created\n     *\n     * @param base headers to append/overwrite to\n     * @param append headers to append/overwrite with\n     * @returns the base headers instance with merged `Headers`\n     */\n    static mergeHeaders(base, ...append) {\n        base = base instanceof Headers ? base : new Headers(base);\n        for (const headers of append) {\n            const add = headers instanceof Headers ? headers : new Headers(headers);\n            add.forEach((value, key) => {\n                // set-cookie is the only header that would repeat.\n                // A bit of background: https://developer.mozilla.org/en-US/docs/Web/API/Headers/getSetCookie\n                key === 'set-cookie' ? base.append(key, value) : base.set(key, value);\n            });\n        }\n        return base;\n    }\n}\nexports.Gaxios = Gaxios;\n_a = Gaxios;\n//# sourceMappingURL=gaxios.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ2F4aW9zL2J1aWxkL2Nqcy9zcmMvZ2F4aW9zLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxjQUFjO0FBQ2QsaUNBQWlDLG1CQUFPLENBQUMsb0RBQVE7QUFDakQsZ0JBQWdCLG1CQUFPLENBQUMsb0JBQU87QUFDL0Isb0JBQW9CLG1CQUFPLENBQUMsd0VBQWE7QUFDekMsbUJBQW1CLG1CQUFPLENBQUMsc0VBQVk7QUFDdkMsaUJBQWlCLG1CQUFPLENBQUMsc0JBQVE7QUFDakMseUJBQXlCLG1CQUFPLENBQUMsa0ZBQWtCO0FBQ25ELHlFQUF5RSxrSEFBZ0I7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHFCQUFxQixtQkFBbUIsYUFBYTtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGdCQUFnQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsaUNBQWlDO0FBQ25FO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyx1QkFBdUI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQSxvQ0FBb0MsY0FBYztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZJQUE2SSwwQkFBMEI7QUFDdks7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwySEFBMkgsY0FBYztBQUN6STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx1QkFBdUI7QUFDdEM7QUFDQSxpQkFBaUIsZ0NBQWdDO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHVCQUF1QjtBQUN0QztBQUNBLGlCQUFpQixnQ0FBZ0M7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxXQUFXLFNBQVM7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx5QkFBeUI7QUFDeEMsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQSw0QkFBNEIsU0FBUztBQUNyQztBQUNBO0FBQ0Esa0NBQWtDLFNBQVMsb0JBQW9CLGdCQUFnQjtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDhCQUE4QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIseUJBQXlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxxZEFBMkI7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG9lQUFvQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ob21ld29ydGgtYWktcHJvcGVydHktdmFsdWF0aW9uLy4vbm9kZV9tb2R1bGVzL2dheGlvcy9idWlsZC9janMvc3JjL2dheGlvcy5qcz85Y2ZhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gQ29weXJpZ2h0IDIwMTggR29vZ2xlIExMQ1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG52YXIgX2E7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkdheGlvcyA9IHZvaWQgMDtcbmNvbnN0IGV4dGVuZF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJleHRlbmRcIikpO1xuY29uc3QgaHR0cHNfMSA9IHJlcXVpcmUoXCJodHRwc1wiKTtcbmNvbnN0IGNvbW1vbl9qc18xID0gcmVxdWlyZShcIi4vY29tbW9uLmpzXCIpO1xuY29uc3QgcmV0cnlfanNfMSA9IHJlcXVpcmUoXCIuL3JldHJ5LmpzXCIpO1xuY29uc3Qgc3RyZWFtXzEgPSByZXF1aXJlKFwic3RyZWFtXCIpO1xuY29uc3QgaW50ZXJjZXB0b3JfanNfMSA9IHJlcXVpcmUoXCIuL2ludGVyY2VwdG9yLmpzXCIpO1xuY29uc3QgcmFuZG9tVVVJRCA9IGFzeW5jICgpID0+IGdsb2JhbFRoaXMuY3J5cHRvPy5yYW5kb21VVUlEKCkgfHwgKGF3YWl0IGltcG9ydCgnY3J5cHRvJykpLnJhbmRvbVVVSUQoKTtcbmNsYXNzIEdheGlvcyB7XG4gICAgYWdlbnRDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IEhUVFAgb3B0aW9ucyB0aGF0IHdpbGwgYmUgdXNlZCBmb3IgZXZlcnkgSFRUUCByZXF1ZXN0LlxuICAgICAqL1xuICAgIGRlZmF1bHRzO1xuICAgIC8qKlxuICAgICAqIEludGVyY2VwdG9yc1xuICAgICAqL1xuICAgIGludGVyY2VwdG9ycztcbiAgICAvKipcbiAgICAgKiBUaGUgR2F4aW9zIGNsYXNzIGlzIHJlc3BvbnNpYmxlIGZvciBtYWtpbmcgSFRUUCByZXF1ZXN0cy5cbiAgICAgKiBAcGFyYW0gZGVmYXVsdHMgVGhlIGRlZmF1bHQgc2V0IG9mIG9wdGlvbnMgdG8gYmUgdXNlZCBmb3IgdGhpcyBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihkZWZhdWx0cykge1xuICAgICAgICB0aGlzLmRlZmF1bHRzID0gZGVmYXVsdHMgfHwge307XG4gICAgICAgIHRoaXMuaW50ZXJjZXB0b3JzID0ge1xuICAgICAgICAgICAgcmVxdWVzdDogbmV3IGludGVyY2VwdG9yX2pzXzEuR2F4aW9zSW50ZXJjZXB0b3JNYW5hZ2VyKCksXG4gICAgICAgICAgICByZXNwb25zZTogbmV3IGludGVyY2VwdG9yX2pzXzEuR2F4aW9zSW50ZXJjZXB0b3JNYW5hZ2VyKCksXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEge0BsaW5rIGZldGNoIGBmZXRjaGB9IGNvbXBsaWFudCBBUEkgZm9yIHtAbGluayBHYXhpb3N9LlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKlxuICAgICAqIFRoaXMgaXMgdXNlZnVsIGFzIGEgZHJvcC1pbiByZXBsYWNlbWVudCBmb3IgYGZldGNoYCBBUEkgdXNhZ2UuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogYGBgdHNcbiAgICAgKiBjb25zdCBnYXhpb3MgPSBuZXcgR2F4aW9zKCk7XG4gICAgICogY29uc3QgbXlGZXRjaDogdHlwZW9mIGZldGNoID0gKC4uLmFyZ3MpID0+IGdheGlvcy5mZXRjaCguLi5hcmdzKTtcbiAgICAgKiBhd2FpdCBteUZldGNoKCdodHRwczovL2V4YW1wbGUuY29tJyk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYXJncyBgZmV0Y2hgIEFQSSBvciBgR2F4aW9zI3JlcXVlc3RgIHBhcmFtZXRlcnNcbiAgICAgKiBAcmV0dXJucyB0aGUge0BsaW5rIFJlc3BvbnNlfSB3aXRoIEdheGlvcy1hZGRlZCBwcm9wZXJ0aWVzXG4gICAgICovXG4gICAgZmV0Y2goLi4uYXJncykge1xuICAgICAgICAvLyBVcCB0byAyIHBhcmFtZXRlcnMgaW4gZWl0aGVyIG92ZXJsb2FkXG4gICAgICAgIGNvbnN0IGlucHV0ID0gYXJnc1swXTtcbiAgICAgICAgY29uc3QgaW5pdCA9IGFyZ3NbMV07XG4gICAgICAgIGxldCB1cmwgPSB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSBuZXcgSGVhZGVycygpO1xuICAgICAgICAvLyBwcmVwYXJlIFVSTFxuICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdXJsID0gbmV3IFVSTChpbnB1dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaW5wdXQgaW5zdGFuY2VvZiBVUkwpIHtcbiAgICAgICAgICAgIHVybCA9IGlucHV0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlucHV0ICYmIGlucHV0LnVybCkge1xuICAgICAgICAgICAgdXJsID0gbmV3IFVSTChpbnB1dC51cmwpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHByZXBhcmUgaGVhZGVyc1xuICAgICAgICBpZiAoaW5wdXQgJiYgdHlwZW9mIGlucHV0ID09PSAnb2JqZWN0JyAmJiAnaGVhZGVycycgaW4gaW5wdXQpIHtcbiAgICAgICAgICAgIF9hLm1lcmdlSGVhZGVycyhoZWFkZXJzLCBpbnB1dC5oZWFkZXJzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5pdCkge1xuICAgICAgICAgICAgX2EubWVyZ2VIZWFkZXJzKGhlYWRlcnMsIG5ldyBIZWFkZXJzKGluaXQuaGVhZGVycykpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHByZXBhcmUgcmVxdWVzdFxuICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnb2JqZWN0JyAmJiAhKGlucHV0IGluc3RhbmNlb2YgVVJMKSkge1xuICAgICAgICAgICAgLy8gaW5wdXQgbXVzdCBoYXZlIGJlZW4gYSBub24tVVJMIG9iamVjdFxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdCh7IC4uLmluaXQsIC4uLmlucHV0LCBoZWFkZXJzLCB1cmwgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBpbnB1dCBtdXN0IGhhdmUgYmVlbiBhIHN0cmluZyBvciBVUkxcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QoeyAuLi5pbml0LCBoZWFkZXJzLCB1cmwgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUGVyZm9ybSBhbiBIVFRQIHJlcXVlc3Qgd2l0aCB0aGUgZ2l2ZW4gb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0gb3B0cyBTZXQgb2YgSFRUUCBvcHRpb25zIHRoYXQgd2lsbCBiZSB1c2VkIGZvciB0aGlzIEhUVFAgcmVxdWVzdC5cbiAgICAgKi9cbiAgICBhc3luYyByZXF1ZXN0KG9wdHMgPSB7fSkge1xuICAgICAgICBsZXQgcHJlcGFyZWQgPSBhd2FpdCB0aGlzLiNwcmVwYXJlUmVxdWVzdChvcHRzKTtcbiAgICAgICAgcHJlcGFyZWQgPSBhd2FpdCB0aGlzLiNhcHBseVJlcXVlc3RJbnRlcmNlcHRvcnMocHJlcGFyZWQpO1xuICAgICAgICByZXR1cm4gdGhpcy4jYXBwbHlSZXNwb25zZUludGVyY2VwdG9ycyh0aGlzLl9yZXF1ZXN0KHByZXBhcmVkKSk7XG4gICAgfVxuICAgIGFzeW5jIF9kZWZhdWx0QWRhcHRlcihjb25maWcpIHtcbiAgICAgICAgY29uc3QgZmV0Y2hJbXBsID0gY29uZmlnLmZldGNoSW1wbGVtZW50YXRpb24gfHxcbiAgICAgICAgICAgIHRoaXMuZGVmYXVsdHMuZmV0Y2hJbXBsZW1lbnRhdGlvbiB8fFxuICAgICAgICAgICAgKGF3YWl0IF9hLiNnZXRGZXRjaCgpKTtcbiAgICAgICAgLy8gbm9kZS1mZXRjaCB2MyB3YXJucyB3aGVuIGBkYXRhYCBpcyBwcmVzZW50XG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlLWZldGNoL25vZGUtZmV0Y2gvaXNzdWVzLzEwMDBcbiAgICAgICAgY29uc3QgcHJlcGFyZWRPcHRzID0geyAuLi5jb25maWcgfTtcbiAgICAgICAgZGVsZXRlIHByZXBhcmVkT3B0cy5kYXRhO1xuICAgICAgICBjb25zdCByZXMgPSAoYXdhaXQgZmV0Y2hJbXBsKGNvbmZpZy51cmwsIHByZXBhcmVkT3B0cykpO1xuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5nZXRSZXNwb25zZURhdGEoY29uZmlnLCByZXMpO1xuICAgICAgICBpZiAoIU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocmVzLCAnZGF0YScpPy5jb25maWd1cmFibGUpIHtcbiAgICAgICAgICAgIC8vIFdvcmstYXJvdW5kIGZvciBgbm9kZS1mZXRjaGAgdjMgYXMgYWNjZXNzaW5nIGBkYXRhYCB3b3VsZCBvdGhlcndpc2UgdGhyb3dcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHJlcywge1xuICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGRhdGEsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIEtlZXAgb2JqZWN0IGFzIGFuIGluc3RhbmNlIG9mIGBSZXNwb25zZWBcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24ocmVzLCB7IGNvbmZpZywgZGF0YSB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwsIHJldHJ5YWJsZSB2ZXJzaW9uIG9mIHRoZSBgcmVxdWVzdGAgbWV0aG9kLlxuICAgICAqIEBwYXJhbSBvcHRzIFNldCBvZiBIVFRQIG9wdGlvbnMgdGhhdCB3aWxsIGJlIHVzZWQgZm9yIHRoaXMgSFRUUCByZXF1ZXN0LlxuICAgICAqL1xuICAgIGFzeW5jIF9yZXF1ZXN0KG9wdHMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxldCB0cmFuc2xhdGVkUmVzcG9uc2U7XG4gICAgICAgICAgICBpZiAob3B0cy5hZGFwdGVyKSB7XG4gICAgICAgICAgICAgICAgdHJhbnNsYXRlZFJlc3BvbnNlID0gYXdhaXQgb3B0cy5hZGFwdGVyKG9wdHMsIHRoaXMuX2RlZmF1bHRBZGFwdGVyLmJpbmQodGhpcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdHJhbnNsYXRlZFJlc3BvbnNlID0gYXdhaXQgdGhpcy5fZGVmYXVsdEFkYXB0ZXIob3B0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW9wdHMudmFsaWRhdGVTdGF0dXModHJhbnNsYXRlZFJlc3BvbnNlLnN0YXR1cykpIHtcbiAgICAgICAgICAgICAgICBpZiAob3B0cy5yZXNwb25zZVR5cGUgPT09ICdzdHJlYW0nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gW107XG4gICAgICAgICAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgdHJhbnNsYXRlZFJlc3BvbnNlLmRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnB1c2goY2h1bmspO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0ZWRSZXNwb25zZS5kYXRhID0gcmVzcG9uc2UudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3JJbmZvID0gY29tbW9uX2pzXzEuR2F4aW9zRXJyb3IuZXh0cmFjdEFQSUVycm9yRnJvbVJlc3BvbnNlKHRyYW5zbGF0ZWRSZXNwb25zZSwgYFJlcXVlc3QgZmFpbGVkIHdpdGggc3RhdHVzIGNvZGUgJHt0cmFuc2xhdGVkUmVzcG9uc2Uuc3RhdHVzfWApO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBjb21tb25fanNfMS5HYXhpb3NFcnJvcihlcnJvckluZm8/Lm1lc3NhZ2UsIG9wdHMsIHRyYW5zbGF0ZWRSZXNwb25zZSwgZXJyb3JJbmZvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cmFuc2xhdGVkUmVzcG9uc2U7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGxldCBlcnI7XG4gICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIGNvbW1vbl9qc18xLkdheGlvc0Vycm9yKSB7XG4gICAgICAgICAgICAgICAgZXJyID0gZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGUgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgIGVyciA9IG5ldyBjb21tb25fanNfMS5HYXhpb3NFcnJvcihlLm1lc3NhZ2UsIG9wdHMsIHVuZGVmaW5lZCwgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBlcnIgPSBuZXcgY29tbW9uX2pzXzEuR2F4aW9zRXJyb3IoJ1VuZXhwZWN0ZWQgR2F4aW9zIEVycm9yJywgb3B0cywgdW5kZWZpbmVkLCBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgc2hvdWxkUmV0cnksIGNvbmZpZyB9ID0gYXdhaXQgKDAsIHJldHJ5X2pzXzEuZ2V0UmV0cnlDb25maWcpKGVycik7XG4gICAgICAgICAgICBpZiAoc2hvdWxkUmV0cnkgJiYgY29uZmlnKSB7XG4gICAgICAgICAgICAgICAgZXJyLmNvbmZpZy5yZXRyeUNvbmZpZy5jdXJyZW50UmV0cnlBdHRlbXB0ID1cbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLnJldHJ5Q29uZmlnLmN1cnJlbnRSZXRyeUF0dGVtcHQ7XG4gICAgICAgICAgICAgICAgLy8gVGhlIGVycm9yJ3MgY29uZmlnIGNvdWxkIGJlIHJlZGFjdGVkIC0gdGhlcmVmb3JlIHdlIG9ubHkgd2FudCB0b1xuICAgICAgICAgICAgICAgIC8vIGNvcHkgdGhlIHJldHJ5IHN0YXRlIG92ZXIgdG8gdGhlIGV4aXN0aW5nIGNvbmZpZ1xuICAgICAgICAgICAgICAgIG9wdHMucmV0cnlDb25maWcgPSBlcnIuY29uZmlnPy5yZXRyeUNvbmZpZztcbiAgICAgICAgICAgICAgICAvLyByZS1wcmVwYXJlIHRpbWVvdXQgZm9yIHRoZSBuZXh0IHJlcXVlc3RcbiAgICAgICAgICAgICAgICB0aGlzLiNhcHBlbmRUaW1lb3V0VG9TaWduYWwob3B0cyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3Qob3B0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0cy5lcnJvclJlZGFjdG9yKSB7XG4gICAgICAgICAgICAgICAgb3B0cy5lcnJvclJlZGFjdG9yKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZ2V0UmVzcG9uc2VEYXRhKG9wdHMsIHJlcykge1xuICAgICAgICBpZiAob3B0cy5tYXhDb250ZW50TGVuZ3RoICYmXG4gICAgICAgICAgICByZXMuaGVhZGVycy5oYXMoJ2NvbnRlbnQtbGVuZ3RoJykgJiZcbiAgICAgICAgICAgIG9wdHMubWF4Q29udGVudExlbmd0aCA8XG4gICAgICAgICAgICAgICAgTnVtYmVyLnBhcnNlSW50KHJlcy5oZWFkZXJzPy5nZXQoJ2NvbnRlbnQtbGVuZ3RoJykgfHwgJycpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgY29tbW9uX2pzXzEuR2F4aW9zRXJyb3IoXCJSZXNwb25zZSdzIGBDb250ZW50LUxlbmd0aGAgaXMgb3ZlciB0aGUgbGltaXQuXCIsIG9wdHMsIE9iamVjdC5hc3NpZ24ocmVzLCB7IGNvbmZpZzogb3B0cyB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChvcHRzLnJlc3BvbnNlVHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnc3RyZWFtJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzLmJvZHk7XG4gICAgICAgICAgICBjYXNlICdqc29uJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzLmpzb24oKTtcbiAgICAgICAgICAgIGNhc2UgJ2FycmF5YnVmZmVyJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzLmFycmF5QnVmZmVyKCk7XG4gICAgICAgICAgICBjYXNlICdibG9iJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzLmJsb2IoKTtcbiAgICAgICAgICAgIGNhc2UgJ3RleHQnOlxuICAgICAgICAgICAgICAgIHJldHVybiByZXMudGV4dCgpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRSZXNwb25zZURhdGFGcm9tQ29udGVudFR5cGUocmVzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAjdXJsTWF5VXNlUHJveHkodXJsLCBub1Byb3h5ID0gW10pIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gbmV3IFVSTCh1cmwpO1xuICAgICAgICBjb25zdCBub1Byb3h5TGlzdCA9IFsuLi5ub1Byb3h5XTtcbiAgICAgICAgY29uc3Qgbm9Qcm94eUVudkxpc3QgPSAocHJvY2Vzcy5lbnYuTk9fUFJPWFkgPz8gcHJvY2Vzcy5lbnYubm9fcHJveHkpPy5zcGxpdCgnLCcpIHx8IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHJ1bGUgb2Ygbm9Qcm94eUVudkxpc3QpIHtcbiAgICAgICAgICAgIG5vUHJveHlMaXN0LnB1c2gocnVsZS50cmltKCkpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgcnVsZSBvZiBub1Byb3h5TGlzdCkge1xuICAgICAgICAgICAgLy8gTWF0Y2ggcmVnZXhcbiAgICAgICAgICAgIGlmIChydWxlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJ1bGUudGVzdChjYW5kaWRhdGUudG9TdHJpbmcoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE1hdGNoIFVSTFxuICAgICAgICAgICAgZWxzZSBpZiAocnVsZSBpbnN0YW5jZW9mIFVSTCkge1xuICAgICAgICAgICAgICAgIGlmIChydWxlLm9yaWdpbiA9PT0gY2FuZGlkYXRlLm9yaWdpbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTWF0Y2ggc3RyaW5nIHJlZ2V4XG4gICAgICAgICAgICBlbHNlIGlmIChydWxlLnN0YXJ0c1dpdGgoJyouJykgfHwgcnVsZS5zdGFydHNXaXRoKCcuJykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjbGVhbmVkUnVsZSA9IHJ1bGUucmVwbGFjZSgvXlxcKlxcLi8sICcuJyk7XG4gICAgICAgICAgICAgICAgaWYgKGNhbmRpZGF0ZS5ob3N0bmFtZS5lbmRzV2l0aChjbGVhbmVkUnVsZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEJhc2ljIHN0cmluZyBtYXRjaFxuICAgICAgICAgICAgZWxzZSBpZiAocnVsZSA9PT0gY2FuZGlkYXRlLm9yaWdpbiB8fFxuICAgICAgICAgICAgICAgIHJ1bGUgPT09IGNhbmRpZGF0ZS5ob3N0bmFtZSB8fFxuICAgICAgICAgICAgICAgIHJ1bGUgPT09IGNhbmRpZGF0ZS5ocmVmKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIHRoZSByZXF1ZXN0IGludGVyY2VwdG9ycy4gVGhlIHJlcXVlc3QgaW50ZXJjZXB0b3JzIGFyZSBhcHBsaWVkIGFmdGVyIHRoZVxuICAgICAqIGNhbGwgdG8gcHJlcGFyZVJlcXVlc3QgaXMgY29tcGxldGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtHYXhpb3NPcHRpb25zUHJlcGFyZWR9IG9wdGlvbnMgVGhlIGN1cnJlbnQgc2V0IG9mIG9wdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxHYXhpb3NPcHRpb25zUHJlcGFyZWQ+fSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIHNldCBvZiBvcHRpb25zIG9yIHJlc3BvbnNlIGFmdGVyIGludGVyY2VwdG9ycyBhcmUgYXBwbGllZC5cbiAgICAgKi9cbiAgICBhc3luYyAjYXBwbHlSZXF1ZXN0SW50ZXJjZXB0b3JzKG9wdGlvbnMpIHtcbiAgICAgICAgbGV0IHByb21pc2VDaGFpbiA9IFByb21pc2UucmVzb2x2ZShvcHRpb25zKTtcbiAgICAgICAgZm9yIChjb25zdCBpbnRlcmNlcHRvciBvZiB0aGlzLmludGVyY2VwdG9ycy5yZXF1ZXN0LnZhbHVlcygpKSB7XG4gICAgICAgICAgICBpZiAoaW50ZXJjZXB0b3IpIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlQ2hhaW4gPSBwcm9taXNlQ2hhaW4udGhlbihpbnRlcmNlcHRvci5yZXNvbHZlZCwgaW50ZXJjZXB0b3IucmVqZWN0ZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcm9taXNlQ2hhaW47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgdGhlIHJlc3BvbnNlIGludGVyY2VwdG9ycy4gVGhlIHJlc3BvbnNlIGludGVyY2VwdG9ycyBhcmUgYXBwbGllZCBhZnRlciB0aGVcbiAgICAgKiBjYWxsIHRvIHJlcXVlc3QgaXMgbWFkZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7R2F4aW9zT3B0aW9uc1ByZXBhcmVkfSBvcHRpb25zIFRoZSBjdXJyZW50IHNldCBvZiBvcHRpb25zLlxuICAgICAqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8R2F4aW9zT3B0aW9uc1ByZXBhcmVkPn0gUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBzZXQgb2Ygb3B0aW9ucyBvciByZXNwb25zZSBhZnRlciBpbnRlcmNlcHRvcnMgYXJlIGFwcGxpZWQuXG4gICAgICovXG4gICAgYXN5bmMgI2FwcGx5UmVzcG9uc2VJbnRlcmNlcHRvcnMocmVzcG9uc2UpIHtcbiAgICAgICAgbGV0IHByb21pc2VDaGFpbiA9IFByb21pc2UucmVzb2x2ZShyZXNwb25zZSk7XG4gICAgICAgIGZvciAoY29uc3QgaW50ZXJjZXB0b3Igb2YgdGhpcy5pbnRlcmNlcHRvcnMucmVzcG9uc2UudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIGlmIChpbnRlcmNlcHRvcikge1xuICAgICAgICAgICAgICAgIHByb21pc2VDaGFpbiA9IHByb21pc2VDaGFpbi50aGVuKGludGVyY2VwdG9yLnJlc29sdmVkLCBpbnRlcmNlcHRvci5yZWplY3RlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByb21pc2VDaGFpbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVmFsaWRhdGVzIHRoZSBvcHRpb25zLCBtZXJnZXMgdGhlbSB3aXRoIGRlZmF1bHRzLCBhbmQgcHJlcGFyZSByZXF1ZXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgVGhlIG9yaWdpbmFsIG9wdGlvbnMgcGFzc2VkIGZyb20gdGhlIGNsaWVudC5cbiAgICAgKiBAcmV0dXJucyBQcmVwYXJlZCBvcHRpb25zLCByZWFkeSB0byBtYWtlIGEgcmVxdWVzdFxuICAgICAqL1xuICAgIGFzeW5jICNwcmVwYXJlUmVxdWVzdChvcHRpb25zKSB7XG4gICAgICAgIC8vIFByZXBhcmUgSGVhZGVycyAtIGNvcHkgaW4gb3JkZXIgdG8gbm90IG11dGF0ZSB0aGUgb3JpZ2luYWwgb2JqZWN0c1xuICAgICAgICBjb25zdCBwcmVwYXJlZEhlYWRlcnMgPSBuZXcgSGVhZGVycyh0aGlzLmRlZmF1bHRzLmhlYWRlcnMpO1xuICAgICAgICBfYS5tZXJnZUhlYWRlcnMocHJlcGFyZWRIZWFkZXJzLCBvcHRpb25zLmhlYWRlcnMpO1xuICAgICAgICAvLyBNZXJnZSBvcHRpb25zXG4gICAgICAgIGNvbnN0IG9wdHMgPSAoMCwgZXh0ZW5kXzEuZGVmYXVsdCkodHJ1ZSwge30sIHRoaXMuZGVmYXVsdHMsIG9wdGlvbnMpO1xuICAgICAgICBpZiAoIW9wdHMudXJsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VSTCBpcyByZXF1aXJlZC4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0cy5iYXNlVVJMKSB7XG4gICAgICAgICAgICBvcHRzLnVybCA9IG5ldyBVUkwob3B0cy51cmwsIG9wdHMuYmFzZVVSTCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZG9uJ3QgbW9kaWZ5IHRoZSBwcm9wZXJ0aWVzIG9mIGEgZGVmYXVsdCBvciBwcm92aWRlZCBVUkxcbiAgICAgICAgb3B0cy51cmwgPSBuZXcgVVJMKG9wdHMudXJsKTtcbiAgICAgICAgaWYgKG9wdHMucGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAob3B0cy5wYXJhbXNTZXJpYWxpemVyKSB7XG4gICAgICAgICAgICAgICAgbGV0IGFkZGl0aW9uYWxRdWVyeVBhcmFtcyA9IG9wdHMucGFyYW1zU2VyaWFsaXplcihvcHRzLnBhcmFtcyk7XG4gICAgICAgICAgICAgICAgaWYgKGFkZGl0aW9uYWxRdWVyeVBhcmFtcy5zdGFydHNXaXRoKCc/JykpIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkaXRpb25hbFF1ZXJ5UGFyYW1zID0gYWRkaXRpb25hbFF1ZXJ5UGFyYW1zLnNsaWNlKDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBwcmVmaXggPSBvcHRzLnVybC50b1N0cmluZygpLmluY2x1ZGVzKCc/JykgPyAnJicgOiAnPyc7XG4gICAgICAgICAgICAgICAgb3B0cy51cmwgPSBvcHRzLnVybCArIHByZWZpeCArIGFkZGl0aW9uYWxRdWVyeVBhcmFtcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHVybCA9IG9wdHMudXJsIGluc3RhbmNlb2YgVVJMID8gb3B0cy51cmwgOiBuZXcgVVJMKG9wdHMudXJsKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBuZXcgVVJMU2VhcmNoUGFyYW1zKG9wdHMucGFyYW1zKSkge1xuICAgICAgICAgICAgICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChrZXksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3B0cy51cmwgPSB1cmw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLm1heENvbnRlbnRMZW5ndGggPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBvcHRzLnNpemUgPSBvcHRpb25zLm1heENvbnRlbnRMZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLm1heFJlZGlyZWN0cyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIG9wdHMuZm9sbG93ID0gb3B0aW9ucy5tYXhSZWRpcmVjdHM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2hvdWxkRGlyZWN0bHlQYXNzRGF0YSA9IHR5cGVvZiBvcHRzLmRhdGEgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICAgICBvcHRzLmRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciB8fFxuICAgICAgICAgICAgb3B0cy5kYXRhIGluc3RhbmNlb2YgQmxvYiB8fFxuICAgICAgICAgICAgLy8gTm9kZSAxOCBkb2VzIG5vdCBoYXZlIGEgZ2xvYmFsIGBGaWxlYCBvYmplY3RcbiAgICAgICAgICAgIChnbG9iYWxUaGlzLkZpbGUgJiYgb3B0cy5kYXRhIGluc3RhbmNlb2YgRmlsZSkgfHxcbiAgICAgICAgICAgIG9wdHMuZGF0YSBpbnN0YW5jZW9mIEZvcm1EYXRhIHx8XG4gICAgICAgICAgICBvcHRzLmRhdGEgaW5zdGFuY2VvZiBzdHJlYW1fMS5SZWFkYWJsZSB8fFxuICAgICAgICAgICAgb3B0cy5kYXRhIGluc3RhbmNlb2YgUmVhZGFibGVTdHJlYW0gfHxcbiAgICAgICAgICAgIG9wdHMuZGF0YSBpbnN0YW5jZW9mIFN0cmluZyB8fFxuICAgICAgICAgICAgb3B0cy5kYXRhIGluc3RhbmNlb2YgVVJMU2VhcmNoUGFyYW1zIHx8XG4gICAgICAgICAgICBBcnJheUJ1ZmZlci5pc1ZpZXcob3B0cy5kYXRhKSB8fCAvLyBgQnVmZmVyYCAoTm9kZS5qcyksIGBEYXRhVmlld2AsIGBUeXBlZEFycmF5YFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAZGVwcmVjYXRlZCBgbm9kZS1mZXRjaGAgb3IgYW5vdGhlciB0aGlyZC1wYXJ0eSdzIHJlcXVlc3QgdHlwZXNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgWydCbG9iJywgJ0ZpbGUnLCAnRm9ybURhdGEnXS5pbmNsdWRlcyhvcHRzLmRhdGE/LmNvbnN0cnVjdG9yPy5uYW1lIHx8ICcnKTtcbiAgICAgICAgaWYgKG9wdHMubXVsdGlwYXJ0Py5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IGJvdW5kYXJ5ID0gYXdhaXQgcmFuZG9tVVVJRCgpO1xuICAgICAgICAgICAgcHJlcGFyZWRIZWFkZXJzLnNldCgnY29udGVudC10eXBlJywgYG11bHRpcGFydC9yZWxhdGVkOyBib3VuZGFyeT0ke2JvdW5kYXJ5fWApO1xuICAgICAgICAgICAgb3B0cy5ib2R5ID0gc3RyZWFtXzEuUmVhZGFibGUuZnJvbSh0aGlzLmdldE11bHRpcGFydFJlcXVlc3Qob3B0cy5tdWx0aXBhcnQsIGJvdW5kYXJ5KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2hvdWxkRGlyZWN0bHlQYXNzRGF0YSkge1xuICAgICAgICAgICAgb3B0cy5ib2R5ID0gb3B0cy5kYXRhO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvcHRzLmRhdGEgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBpZiAocHJlcGFyZWRIZWFkZXJzLmdldCgnQ29udGVudC1UeXBlJykgPT09XG4gICAgICAgICAgICAgICAgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB3d3ctZm9ybS11cmxlbmNvZGVkIGNvbnRlbnQgdHlwZSBoYXMgYmVlbiBzZXQsIGJ1dCBkYXRhIGlzXG4gICAgICAgICAgICAgICAgLy8gcHJvdmlkZWQgYXMgYW4gb2JqZWN0LCBzZXJpYWxpemUgdGhlIGNvbnRlbnRcbiAgICAgICAgICAgICAgICBvcHRzLmJvZHkgPSBvcHRzLnBhcmFtc1NlcmlhbGl6ZXJcbiAgICAgICAgICAgICAgICAgICAgPyBvcHRzLnBhcmFtc1NlcmlhbGl6ZXIob3B0cy5kYXRhKVxuICAgICAgICAgICAgICAgICAgICA6IG5ldyBVUkxTZWFyY2hQYXJhbXMob3B0cy5kYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICghcHJlcGFyZWRIZWFkZXJzLmhhcygnY29udGVudC10eXBlJykpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJlcGFyZWRIZWFkZXJzLnNldCgnY29udGVudC10eXBlJywgJ2FwcGxpY2F0aW9uL2pzb24nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3B0cy5ib2R5ID0gSlNPTi5zdHJpbmdpZnkob3B0cy5kYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcHRzLmRhdGEpIHtcbiAgICAgICAgICAgIG9wdHMuYm9keSA9IG9wdHMuZGF0YTtcbiAgICAgICAgfVxuICAgICAgICBvcHRzLnZhbGlkYXRlU3RhdHVzID0gb3B0cy52YWxpZGF0ZVN0YXR1cyB8fCB0aGlzLnZhbGlkYXRlU3RhdHVzO1xuICAgICAgICBvcHRzLnJlc3BvbnNlVHlwZSA9IG9wdHMucmVzcG9uc2VUeXBlIHx8ICd1bmtub3duJztcbiAgICAgICAgaWYgKCFwcmVwYXJlZEhlYWRlcnMuaGFzKCdhY2NlcHQnKSAmJiBvcHRzLnJlc3BvbnNlVHlwZSA9PT0gJ2pzb24nKSB7XG4gICAgICAgICAgICBwcmVwYXJlZEhlYWRlcnMuc2V0KCdhY2NlcHQnLCAnYXBwbGljYXRpb24vanNvbicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByb3h5ID0gb3B0cy5wcm94eSB8fFxuICAgICAgICAgICAgcHJvY2Vzcz8uZW52Py5IVFRQU19QUk9YWSB8fFxuICAgICAgICAgICAgcHJvY2Vzcz8uZW52Py5odHRwc19wcm94eSB8fFxuICAgICAgICAgICAgcHJvY2Vzcz8uZW52Py5IVFRQX1BST1hZIHx8XG4gICAgICAgICAgICBwcm9jZXNzPy5lbnY/Lmh0dHBfcHJveHk7XG4gICAgICAgIGlmIChvcHRzLmFnZW50KSB7XG4gICAgICAgICAgICAvLyBkb24ndCBkbyBhbnkgb2YgdGhlIGZvbGxvd2luZyBvcHRpb25zIC0gdXNlIHRoZSB1c2VyLXByb3ZpZGVkIGFnZW50LlxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByb3h5ICYmIHRoaXMuI3VybE1heVVzZVByb3h5KG9wdHMudXJsLCBvcHRzLm5vUHJveHkpKSB7XG4gICAgICAgICAgICBjb25zdCBIdHRwc1Byb3h5QWdlbnQgPSBhd2FpdCBfYS4jZ2V0UHJveHlBZ2VudCgpO1xuICAgICAgICAgICAgaWYgKHRoaXMuYWdlbnRDYWNoZS5oYXMocHJveHkpKSB7XG4gICAgICAgICAgICAgICAgb3B0cy5hZ2VudCA9IHRoaXMuYWdlbnRDYWNoZS5nZXQocHJveHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb3B0cy5hZ2VudCA9IG5ldyBIdHRwc1Byb3h5QWdlbnQocHJveHksIHtcbiAgICAgICAgICAgICAgICAgICAgY2VydDogb3B0cy5jZXJ0LFxuICAgICAgICAgICAgICAgICAgICBrZXk6IG9wdHMua2V5LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuYWdlbnRDYWNoZS5zZXQocHJveHksIG9wdHMuYWdlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wdHMuY2VydCAmJiBvcHRzLmtleSkge1xuICAgICAgICAgICAgLy8gQ29uZmlndXJlIGNsaWVudCBmb3IgbVRMU1xuICAgICAgICAgICAgaWYgKHRoaXMuYWdlbnRDYWNoZS5oYXMob3B0cy5rZXkpKSB7XG4gICAgICAgICAgICAgICAgb3B0cy5hZ2VudCA9IHRoaXMuYWdlbnRDYWNoZS5nZXQob3B0cy5rZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb3B0cy5hZ2VudCA9IG5ldyBodHRwc18xLkFnZW50KHtcbiAgICAgICAgICAgICAgICAgICAgY2VydDogb3B0cy5jZXJ0LFxuICAgICAgICAgICAgICAgICAgICBrZXk6IG9wdHMua2V5LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuYWdlbnRDYWNoZS5zZXQob3B0cy5rZXksIG9wdHMuYWdlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0cy5lcnJvclJlZGFjdG9yICE9PSAnZnVuY3Rpb24nICYmXG4gICAgICAgICAgICBvcHRzLmVycm9yUmVkYWN0b3IgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICBvcHRzLmVycm9yUmVkYWN0b3IgPSBjb21tb25fanNfMS5kZWZhdWx0RXJyb3JSZWRhY3RvcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0cy5ib2R5ICYmICEoJ2R1cGxleCcgaW4gb3B0cykpIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogcmVxdWlyZWQgZm9yIE5vZGUuanMgYW5kIHRoZSB0eXBlIGlzbid0IGF2YWlsYWJsZSB0b2RheVxuICAgICAgICAgICAgICogQGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2lzc3Vlcy80NjIyMVxuICAgICAgICAgICAgICogQGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9UeXBlU2NyaXB0LURPTS1saWItZ2VuZXJhdG9yL2lzc3Vlcy8xNDgzXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIG9wdHMuZHVwbGV4ID0gJ2hhbGYnO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI2FwcGVuZFRpbWVvdXRUb1NpZ25hbChvcHRzKTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24ob3B0cywge1xuICAgICAgICAgICAgaGVhZGVyczogcHJlcGFyZWRIZWFkZXJzLFxuICAgICAgICAgICAgdXJsOiBvcHRzLnVybCBpbnN0YW5jZW9mIFVSTCA/IG9wdHMudXJsIDogbmV3IFVSTChvcHRzLnVybCksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAjYXBwZW5kVGltZW91dFRvU2lnbmFsKG9wdHMpIHtcbiAgICAgICAgaWYgKG9wdHMudGltZW91dCkge1xuICAgICAgICAgICAgY29uc3QgdGltZW91dFNpZ25hbCA9IEFib3J0U2lnbmFsLnRpbWVvdXQob3B0cy50aW1lb3V0KTtcbiAgICAgICAgICAgIGlmIChvcHRzLnNpZ25hbCAmJiAhb3B0cy5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgICAgICAgIG9wdHMuc2lnbmFsID0gQWJvcnRTaWduYWwuYW55KFtvcHRzLnNpZ25hbCwgdGltZW91dFNpZ25hbF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb3B0cy5zaWduYWwgPSB0aW1lb3V0U2lnbmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJ5IGRlZmF1bHQsIHRocm93IGZvciBhbnkgbm9uLTJ4eCBzdGF0dXMgY29kZVxuICAgICAqIEBwYXJhbSBzdGF0dXMgc3RhdHVzIGNvZGUgZnJvbSB0aGUgSFRUUCByZXNwb25zZVxuICAgICAqL1xuICAgIHZhbGlkYXRlU3RhdHVzKHN0YXR1cykge1xuICAgICAgICByZXR1cm4gc3RhdHVzID49IDIwMCAmJiBzdGF0dXMgPCAzMDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEF0dGVtcHRzIHRvIHBhcnNlIGEgcmVzcG9uc2UgYnkgbG9va2luZyBhdCB0aGUgQ29udGVudC1UeXBlIGhlYWRlci5cbiAgICAgKiBAcGFyYW0ge1Jlc3BvbnNlfSByZXNwb25zZSB0aGUgSFRUUCByZXNwb25zZS5cbiAgICAgKiBAcmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgcmVzcG9uc2UgZGF0YS5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRSZXNwb25zZURhdGFGcm9tQ29udGVudFR5cGUocmVzcG9uc2UpIHtcbiAgICAgICAgbGV0IGNvbnRlbnRUeXBlID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoJ0NvbnRlbnQtVHlwZScpO1xuICAgICAgICBpZiAoY29udGVudFR5cGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIE1haW50YWluIGV4aXN0aW5nIGZ1bmN0aW9uYWxpdHkgYnkgY2FsbGluZyB0ZXh0KClcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50ZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGVudFR5cGUgPSBjb250ZW50VHlwZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoY29udGVudFR5cGUuaW5jbHVkZXMoJ2FwcGxpY2F0aW9uL2pzb24nKSkge1xuICAgICAgICAgICAgbGV0IGRhdGEgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2gge1xuICAgICAgICAgICAgICAgIC8vIGNvbnRpbnVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb250ZW50VHlwZS5tYXRjaCgvXnRleHRcXC8vKSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRleHQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSBjb250ZW50IHR5cGUgaXMgc29tZXRoaW5nIG5vdCBlYXNpbHkgaGFuZGxlZCwganVzdCByZXR1cm4gdGhlIHJhdyBkYXRhIChibG9iKVxuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmJsb2IoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFzeW5jIGdlbmVyYXRvciB0aGF0IHlpZWxkcyB0aGUgcGllY2VzIG9mIGEgbXVsdGlwYXJ0L3JlbGF0ZWQgcmVxdWVzdCBib2R5LlxuICAgICAqIFRoaXMgaW1wbGVtZW50YXRpb24gZm9sbG93cyB0aGUgc3BlYzogaHR0cHM6Ly93d3cuaWV0Zi5vcmcvcmZjL3JmYzIzODcudHh0LiBIb3dldmVyLCByZWN1cnNpdmVcbiAgICAgKiBtdWx0aXBhcnQvcmVsYXRlZCByZXF1ZXN0cyBhcmUgbm90IGN1cnJlbnRseSBzdXBwb3J0ZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0dheGlvTXVsdGlwYXJ0T3B0aW9uc1tdfSBtdWx0aXBhcnRPcHRpb25zIHRoZSBwaWVjZXMgdG8gdHVybiBpbnRvIGEgbXVsdGlwYXJ0L3JlbGF0ZWQgYm9keS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYm91bmRhcnkgdGhlIGJvdW5kYXJ5IHN0cmluZyB0byBiZSBwbGFjZWQgYmV0d2VlbiBlYWNoIHBhcnQuXG4gICAgICovXG4gICAgYXN5bmMgKmdldE11bHRpcGFydFJlcXVlc3QobXVsdGlwYXJ0T3B0aW9ucywgYm91bmRhcnkpIHtcbiAgICAgICAgY29uc3QgZmluYWxlID0gYC0tJHtib3VuZGFyeX0tLWA7XG4gICAgICAgIGZvciAoY29uc3QgY3VycmVudFBhcnQgb2YgbXVsdGlwYXJ0T3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgcGFydENvbnRlbnRUeXBlID0gY3VycmVudFBhcnQuaGVhZGVycy5nZXQoJ0NvbnRlbnQtVHlwZScpIHx8ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nO1xuICAgICAgICAgICAgY29uc3QgcHJlYW1ibGUgPSBgLS0ke2JvdW5kYXJ5fVxcclxcbkNvbnRlbnQtVHlwZTogJHtwYXJ0Q29udGVudFR5cGV9XFxyXFxuXFxyXFxuYDtcbiAgICAgICAgICAgIHlpZWxkIHByZWFtYmxlO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjdXJyZW50UGFydC5jb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHlpZWxkIGN1cnJlbnRQYXJ0LmNvbnRlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB5aWVsZCogY3VycmVudFBhcnQuY29udGVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHlpZWxkICdcXHJcXG4nO1xuICAgICAgICB9XG4gICAgICAgIHlpZWxkIGZpbmFsZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBjYWNoZSBmb3IgdGhlIGxhemlseS1sb2FkZWQgcHJveHkgYWdlbnQuXG4gICAgICpcbiAgICAgKiBTaG91bGQgdXNlIHtAbGluayBHYXhpb3NbI2dldFByb3h5QWdlbnRdfSB0byByZXRyaWV2ZS5cbiAgICAgKi9cbiAgICAvLyB1c2luZyBgaW1wb3J0YCB0byBkeW5hbWljYWxseSBpbXBvcnQgdGhlIHR5cGVzIGhlcmVcbiAgICBzdGF0aWMgI3Byb3h5QWdlbnQ7XG4gICAgLyoqXG4gICAgICogQSBjYWNoZSBmb3IgdGhlIGxhemlseS1sb2FkZWQgZmV0Y2ggbGlicmFyeS5cbiAgICAgKlxuICAgICAqIFNob3VsZCB1c2Uge0BsaW5rIEdheGlvc1sjZ2V0RmV0Y2hdfSB0byByZXRyaWV2ZS5cbiAgICAgKi9cbiAgICAvL1xuICAgIHN0YXRpYyAjZmV0Y2g7XG4gICAgLyoqXG4gICAgICogSW1wb3J0cywgY2FjaGVzLCBhbmQgcmV0dXJucyBhIHByb3h5IGFnZW50IC0gaWYgbm90IGFscmVhZHkgaW1wb3J0ZWRcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgcHJveHkgYWdlbnRcbiAgICAgKi9cbiAgICBzdGF0aWMgYXN5bmMgI2dldFByb3h5QWdlbnQoKSB7XG4gICAgICAgIHRoaXMuI3Byb3h5QWdlbnQgfHw9IChhd2FpdCBpbXBvcnQoJ2h0dHBzLXByb3h5LWFnZW50JykpLkh0dHBzUHJveHlBZ2VudDtcbiAgICAgICAgcmV0dXJuIHRoaXMuI3Byb3h5QWdlbnQ7XG4gICAgfVxuICAgIHN0YXRpYyBhc3luYyAjZ2V0RmV0Y2goKSB7XG4gICAgICAgIGNvbnN0IGhhc1dpbmRvdyA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmICEhd2luZG93O1xuICAgICAgICB0aGlzLiNmZXRjaCB8fD0gaGFzV2luZG93XG4gICAgICAgICAgICA/IHdpbmRvdy5mZXRjaFxuICAgICAgICAgICAgOiAoYXdhaXQgaW1wb3J0KCdub2RlLWZldGNoJykpLmRlZmF1bHQ7XG4gICAgICAgIHJldHVybiB0aGlzLiNmZXRjaDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWVyZ2VzIGhlYWRlcnMuXG4gICAgICogSWYgdGhlIGJhc2UgaGVhZGVycyBkbyBub3QgZXhpc3QgYSBuZXcgYEhlYWRlcnNgIG9iamVjdCB3aWxsIGJlIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKlxuICAgICAqIFVzaW5nIHRoaXMgdXRpbGl0eSBjYW4gYmUgaGVscGZ1bCB3aGVuIHRoZSBoZWFkZXJzIGFyZSBub3Qga25vd24gdG8gZXhpc3Q6XG4gICAgICogLSBpZiB0aGV5IGV4aXN0IGFzIGBIZWFkZXJzYCwgdGhhdCBpbnN0YW5jZSB3aWxsIGJlIHVzZWRcbiAgICAgKiAgIC0gaXQgaW1wcm92ZXMgcGVyZm9ybWFuY2UgYW5kIGFsbG93cyB1c2VycyB0byB1c2UgdGhlaXIgZXhpc3RpbmcgcmVmZXJlbmNlcyB0byB0aGVpciBgSGVhZGVyc2BcbiAgICAgKiAtIGlmIHRoZXkgZXhpc3QgaW4gYW5vdGhlciBmb3JtIChgSGVhZGVyc0luaXRgKSwgdGhleSB3aWxsIGJlIHVzZWQgdG8gY3JlYXRlIGEgbmV3IGBIZWFkZXJzYCBvYmplY3RcbiAgICAgKiAtIGlmIHRoZSBiYXNlIGhlYWRlcnMgZG8gbm90IGV4aXN0IGEgbmV3IGBIZWFkZXJzYCBvYmplY3Qgd2lsbCBiZSBjcmVhdGVkXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYmFzZSBoZWFkZXJzIHRvIGFwcGVuZC9vdmVyd3JpdGUgdG9cbiAgICAgKiBAcGFyYW0gYXBwZW5kIGhlYWRlcnMgdG8gYXBwZW5kL292ZXJ3cml0ZSB3aXRoXG4gICAgICogQHJldHVybnMgdGhlIGJhc2UgaGVhZGVycyBpbnN0YW5jZSB3aXRoIG1lcmdlZCBgSGVhZGVyc2BcbiAgICAgKi9cbiAgICBzdGF0aWMgbWVyZ2VIZWFkZXJzKGJhc2UsIC4uLmFwcGVuZCkge1xuICAgICAgICBiYXNlID0gYmFzZSBpbnN0YW5jZW9mIEhlYWRlcnMgPyBiYXNlIDogbmV3IEhlYWRlcnMoYmFzZSk7XG4gICAgICAgIGZvciAoY29uc3QgaGVhZGVycyBvZiBhcHBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IGFkZCA9IGhlYWRlcnMgaW5zdGFuY2VvZiBIZWFkZXJzID8gaGVhZGVycyA6IG5ldyBIZWFkZXJzKGhlYWRlcnMpO1xuICAgICAgICAgICAgYWRkLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBzZXQtY29va2llIGlzIHRoZSBvbmx5IGhlYWRlciB0aGF0IHdvdWxkIHJlcGVhdC5cbiAgICAgICAgICAgICAgICAvLyBBIGJpdCBvZiBiYWNrZ3JvdW5kOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSGVhZGVycy9nZXRTZXRDb29raWVcbiAgICAgICAgICAgICAgICBrZXkgPT09ICdzZXQtY29va2llJyA/IGJhc2UuYXBwZW5kKGtleSwgdmFsdWUpIDogYmFzZS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmFzZTtcbiAgICB9XG59XG5leHBvcnRzLkdheGlvcyA9IEdheGlvcztcbl9hID0gR2F4aW9zO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2F4aW9zLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/gaxios/build/cjs/src/gaxios.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/gaxios/build/cjs/src/index.js":
/*!****************************************************!*\
  !*** ./node_modules/gaxios/build/cjs/src/index.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n// Copyright 2018 Google LLC\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.instance = exports.Gaxios = exports.GaxiosError = void 0;\nexports.request = request;\nconst gaxios_js_1 = __webpack_require__(/*! ./gaxios.js */ \"(rsc)/./node_modules/gaxios/build/cjs/src/gaxios.js\");\nObject.defineProperty(exports, \"Gaxios\", ({ enumerable: true, get: function () { return gaxios_js_1.Gaxios; } }));\nvar common_js_1 = __webpack_require__(/*! ./common.js */ \"(rsc)/./node_modules/gaxios/build/cjs/src/common.js\");\nObject.defineProperty(exports, \"GaxiosError\", ({ enumerable: true, get: function () { return common_js_1.GaxiosError; } }));\n__exportStar(__webpack_require__(/*! ./interceptor.js */ \"(rsc)/./node_modules/gaxios/build/cjs/src/interceptor.js\"), exports);\n/**\n * The default instance used when the `request` method is directly\n * invoked.\n */\nexports.instance = new gaxios_js_1.Gaxios();\n/**\n * Make an HTTP request using the given options.\n * @param opts Options for the request\n */\nasync function request(opts) {\n    return exports.instance.request(opts);\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ2F4aW9zL2J1aWxkL2Nqcy9zcmMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZ0JBQWdCLEdBQUcsY0FBYyxHQUFHLG1CQUFtQjtBQUN2RCxlQUFlO0FBQ2Ysb0JBQW9CLG1CQUFPLENBQUMsd0VBQWE7QUFDekMsMENBQXlDLEVBQUUscUNBQXFDLDhCQUE4QixFQUFDO0FBQy9HLGtCQUFrQixtQkFBTyxDQUFDLHdFQUFhO0FBQ3ZDLCtDQUE4QyxFQUFFLHFDQUFxQyxtQ0FBbUMsRUFBQztBQUN6SCxhQUFhLG1CQUFPLENBQUMsa0ZBQWtCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ob21ld29ydGgtYWktcHJvcGVydHktdmFsdWF0aW9uLy4vbm9kZV9tb2R1bGVzL2dheGlvcy9idWlsZC9janMvc3JjL2luZGV4LmpzPzU3NDIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBDb3B5cmlnaHQgMjAxOCBHb29nbGUgTExDXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5pbnN0YW5jZSA9IGV4cG9ydHMuR2F4aW9zID0gZXhwb3J0cy5HYXhpb3NFcnJvciA9IHZvaWQgMDtcbmV4cG9ydHMucmVxdWVzdCA9IHJlcXVlc3Q7XG5jb25zdCBnYXhpb3NfanNfMSA9IHJlcXVpcmUoXCIuL2dheGlvcy5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkdheGlvc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2F4aW9zX2pzXzEuR2F4aW9zOyB9IH0pO1xudmFyIGNvbW1vbl9qc18xID0gcmVxdWlyZShcIi4vY29tbW9uLmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiR2F4aW9zRXJyb3JcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbW1vbl9qc18xLkdheGlvc0Vycm9yOyB9IH0pO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2ludGVyY2VwdG9yLmpzXCIpLCBleHBvcnRzKTtcbi8qKlxuICogVGhlIGRlZmF1bHQgaW5zdGFuY2UgdXNlZCB3aGVuIHRoZSBgcmVxdWVzdGAgbWV0aG9kIGlzIGRpcmVjdGx5XG4gKiBpbnZva2VkLlxuICovXG5leHBvcnRzLmluc3RhbmNlID0gbmV3IGdheGlvc19qc18xLkdheGlvcygpO1xuLyoqXG4gKiBNYWtlIGFuIEhUVFAgcmVxdWVzdCB1c2luZyB0aGUgZ2l2ZW4gb3B0aW9ucy5cbiAqIEBwYXJhbSBvcHRzIE9wdGlvbnMgZm9yIHRoZSByZXF1ZXN0XG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHJlcXVlc3Qob3B0cykge1xuICAgIHJldHVybiBleHBvcnRzLmluc3RhbmNlLnJlcXVlc3Qob3B0cyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/gaxios/build/cjs/src/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/gaxios/build/cjs/src/interceptor.js":
/*!**********************************************************!*\
  !*** ./node_modules/gaxios/build/cjs/src/interceptor.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n// Copyright 2024 Google LLC\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.GaxiosInterceptorManager = void 0;\n/**\n * Class to manage collections of GaxiosInterceptors for both requests and responses.\n */\nclass GaxiosInterceptorManager extends Set {\n}\nexports.GaxiosInterceptorManager = GaxiosInterceptorManager;\n//# sourceMappingURL=interceptor.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ2F4aW9zL2J1aWxkL2Nqcy9zcmMvaW50ZXJjZXB0b3IuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ob21ld29ydGgtYWktcHJvcGVydHktdmFsdWF0aW9uLy4vbm9kZV9tb2R1bGVzL2dheGlvcy9idWlsZC9janMvc3JjL2ludGVyY2VwdG9yLmpzPzJkYjEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBDb3B5cmlnaHQgMjAyNCBHb29nbGUgTExDXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuR2F4aW9zSW50ZXJjZXB0b3JNYW5hZ2VyID0gdm9pZCAwO1xuLyoqXG4gKiBDbGFzcyB0byBtYW5hZ2UgY29sbGVjdGlvbnMgb2YgR2F4aW9zSW50ZXJjZXB0b3JzIGZvciBib3RoIHJlcXVlc3RzIGFuZCByZXNwb25zZXMuXG4gKi9cbmNsYXNzIEdheGlvc0ludGVyY2VwdG9yTWFuYWdlciBleHRlbmRzIFNldCB7XG59XG5leHBvcnRzLkdheGlvc0ludGVyY2VwdG9yTWFuYWdlciA9IEdheGlvc0ludGVyY2VwdG9yTWFuYWdlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWludGVyY2VwdG9yLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/gaxios/build/cjs/src/interceptor.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/gaxios/build/cjs/src/retry.js":
/*!****************************************************!*\
  !*** ./node_modules/gaxios/build/cjs/src/retry.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n// Copyright 2018 Google LLC\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getRetryConfig = getRetryConfig;\nasync function getRetryConfig(err) {\n    let config = getConfig(err);\n    if (!err || !err.config || (!config && !err.config.retry)) {\n        return { shouldRetry: false };\n    }\n    config = config || {};\n    config.currentRetryAttempt = config.currentRetryAttempt || 0;\n    config.retry =\n        config.retry === undefined || config.retry === null ? 3 : config.retry;\n    config.httpMethodsToRetry = config.httpMethodsToRetry || [\n        'GET',\n        'HEAD',\n        'PUT',\n        'OPTIONS',\n        'DELETE',\n    ];\n    config.noResponseRetries =\n        config.noResponseRetries === undefined || config.noResponseRetries === null\n            ? 2\n            : config.noResponseRetries;\n    config.retryDelayMultiplier = config.retryDelayMultiplier\n        ? config.retryDelayMultiplier\n        : 2;\n    config.timeOfFirstRequest = config.timeOfFirstRequest\n        ? config.timeOfFirstRequest\n        : Date.now();\n    config.totalTimeout = config.totalTimeout\n        ? config.totalTimeout\n        : Number.MAX_SAFE_INTEGER;\n    config.maxRetryDelay = config.maxRetryDelay\n        ? config.maxRetryDelay\n        : Number.MAX_SAFE_INTEGER;\n    // If this wasn't in the list of status codes where we want\n    // to automatically retry, return.\n    const retryRanges = [\n        // https://en.wikipedia.org/wiki/List_of_HTTP_status_codes\n        // 1xx - Retry (Informational, request still processing)\n        // 2xx - Do not retry (Success)\n        // 3xx - Do not retry (Redirect)\n        // 4xx - Do not retry (Client errors)\n        // 408 - Retry (\"Request Timeout\")\n        // 429 - Retry (\"Too Many Requests\")\n        // 5xx - Retry (Server errors)\n        [100, 199],\n        [408, 408],\n        [429, 429],\n        [500, 599],\n    ];\n    config.statusCodesToRetry = config.statusCodesToRetry || retryRanges;\n    // Put the config back into the err\n    err.config.retryConfig = config;\n    // Determine if we should retry the request\n    const shouldRetryFn = config.shouldRetry || shouldRetryRequest;\n    if (!(await shouldRetryFn(err))) {\n        return { shouldRetry: false, config: err.config };\n    }\n    const delay = getNextRetryDelay(config);\n    // We're going to retry!  Increment the counter.\n    err.config.retryConfig.currentRetryAttempt += 1;\n    // Create a promise that invokes the retry after the backOffDelay\n    const backoff = config.retryBackoff\n        ? config.retryBackoff(err, delay)\n        : new Promise(resolve => {\n            setTimeout(resolve, delay);\n        });\n    // Notify the user if they added an `onRetryAttempt` handler\n    if (config.onRetryAttempt) {\n        await config.onRetryAttempt(err);\n    }\n    // Return the promise in which recalls Gaxios to retry the request\n    await backoff;\n    return { shouldRetry: true, config: err.config };\n}\n/**\n * Determine based on config if we should retry the request.\n * @param err The GaxiosError passed to the interceptor.\n */\nfunction shouldRetryRequest(err) {\n    const config = getConfig(err);\n    if ((err.config.signal?.aborted && err.code !== 'TimeoutError') ||\n        err.code === 'AbortError') {\n        return false;\n    }\n    // If there's no config, or retries are disabled, return.\n    if (!config || config.retry === 0) {\n        return false;\n    }\n    // Check if this error has no response (ETIMEDOUT, ENOTFOUND, etc)\n    if (!err.response &&\n        (config.currentRetryAttempt || 0) >= config.noResponseRetries) {\n        return false;\n    }\n    // Only retry with configured HttpMethods.\n    if (!config.httpMethodsToRetry ||\n        !config.httpMethodsToRetry.includes(err.config.method?.toUpperCase() || 'GET')) {\n        return false;\n    }\n    // If this wasn't in the list of status codes where we want\n    // to automatically retry, return.\n    if (err.response && err.response.status) {\n        let isInRange = false;\n        for (const [min, max] of config.statusCodesToRetry) {\n            const status = err.response.status;\n            if (status >= min && status <= max) {\n                isInRange = true;\n                break;\n            }\n        }\n        if (!isInRange) {\n            return false;\n        }\n    }\n    // If we are out of retry attempts, return\n    config.currentRetryAttempt = config.currentRetryAttempt || 0;\n    if (config.currentRetryAttempt >= config.retry) {\n        return false;\n    }\n    return true;\n}\n/**\n * Acquire the raxConfig object from an GaxiosError if available.\n * @param err The Gaxios error with a config object.\n */\nfunction getConfig(err) {\n    if (err && err.config && err.config.retryConfig) {\n        return err.config.retryConfig;\n    }\n    return;\n}\n/**\n * Gets the delay to wait before the next retry.\n *\n * @param {RetryConfig} config The current set of retry options\n * @returns {number} the amount of ms to wait before the next retry attempt.\n */\nfunction getNextRetryDelay(config) {\n    // Calculate time to wait with exponential backoff.\n    // If this is the first retry, look for a configured retryDelay.\n    const retryDelay = config.currentRetryAttempt\n        ? 0\n        : (config.retryDelay ?? 100);\n    // Formula: retryDelay + ((retryDelayMultiplier^currentRetryAttempt - 1 / 2) * 1000)\n    const calculatedDelay = retryDelay +\n        ((Math.pow(config.retryDelayMultiplier, config.currentRetryAttempt) - 1) /\n            2) *\n            1000;\n    const maxAllowableDelay = config.totalTimeout - (Date.now() - config.timeOfFirstRequest);\n    return Math.min(calculatedDelay, maxAllowableDelay, config.maxRetryDelay);\n}\n//# sourceMappingURL=retry.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ2F4aW9zL2J1aWxkL2Nqcy9zcmMvcmV0cnkuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2hvbWV3b3J0aC1haS1wcm9wZXJ0eS12YWx1YXRpb24vLi9ub2RlX21vZHVsZXMvZ2F4aW9zL2J1aWxkL2Nqcy9zcmMvcmV0cnkuanM/ODAxOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTENcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRSZXRyeUNvbmZpZyA9IGdldFJldHJ5Q29uZmlnO1xuYXN5bmMgZnVuY3Rpb24gZ2V0UmV0cnlDb25maWcoZXJyKSB7XG4gICAgbGV0IGNvbmZpZyA9IGdldENvbmZpZyhlcnIpO1xuICAgIGlmICghZXJyIHx8ICFlcnIuY29uZmlnIHx8ICghY29uZmlnICYmICFlcnIuY29uZmlnLnJldHJ5KSkge1xuICAgICAgICByZXR1cm4geyBzaG91bGRSZXRyeTogZmFsc2UgfTtcbiAgICB9XG4gICAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xuICAgIGNvbmZpZy5jdXJyZW50UmV0cnlBdHRlbXB0ID0gY29uZmlnLmN1cnJlbnRSZXRyeUF0dGVtcHQgfHwgMDtcbiAgICBjb25maWcucmV0cnkgPVxuICAgICAgICBjb25maWcucmV0cnkgPT09IHVuZGVmaW5lZCB8fCBjb25maWcucmV0cnkgPT09IG51bGwgPyAzIDogY29uZmlnLnJldHJ5O1xuICAgIGNvbmZpZy5odHRwTWV0aG9kc1RvUmV0cnkgPSBjb25maWcuaHR0cE1ldGhvZHNUb1JldHJ5IHx8IFtcbiAgICAgICAgJ0dFVCcsXG4gICAgICAgICdIRUFEJyxcbiAgICAgICAgJ1BVVCcsXG4gICAgICAgICdPUFRJT05TJyxcbiAgICAgICAgJ0RFTEVURScsXG4gICAgXTtcbiAgICBjb25maWcubm9SZXNwb25zZVJldHJpZXMgPVxuICAgICAgICBjb25maWcubm9SZXNwb25zZVJldHJpZXMgPT09IHVuZGVmaW5lZCB8fCBjb25maWcubm9SZXNwb25zZVJldHJpZXMgPT09IG51bGxcbiAgICAgICAgICAgID8gMlxuICAgICAgICAgICAgOiBjb25maWcubm9SZXNwb25zZVJldHJpZXM7XG4gICAgY29uZmlnLnJldHJ5RGVsYXlNdWx0aXBsaWVyID0gY29uZmlnLnJldHJ5RGVsYXlNdWx0aXBsaWVyXG4gICAgICAgID8gY29uZmlnLnJldHJ5RGVsYXlNdWx0aXBsaWVyXG4gICAgICAgIDogMjtcbiAgICBjb25maWcudGltZU9mRmlyc3RSZXF1ZXN0ID0gY29uZmlnLnRpbWVPZkZpcnN0UmVxdWVzdFxuICAgICAgICA/IGNvbmZpZy50aW1lT2ZGaXJzdFJlcXVlc3RcbiAgICAgICAgOiBEYXRlLm5vdygpO1xuICAgIGNvbmZpZy50b3RhbFRpbWVvdXQgPSBjb25maWcudG90YWxUaW1lb3V0XG4gICAgICAgID8gY29uZmlnLnRvdGFsVGltZW91dFxuICAgICAgICA6IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xuICAgIGNvbmZpZy5tYXhSZXRyeURlbGF5ID0gY29uZmlnLm1heFJldHJ5RGVsYXlcbiAgICAgICAgPyBjb25maWcubWF4UmV0cnlEZWxheVxuICAgICAgICA6IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xuICAgIC8vIElmIHRoaXMgd2Fzbid0IGluIHRoZSBsaXN0IG9mIHN0YXR1cyBjb2RlcyB3aGVyZSB3ZSB3YW50XG4gICAgLy8gdG8gYXV0b21hdGljYWxseSByZXRyeSwgcmV0dXJuLlxuICAgIGNvbnN0IHJldHJ5UmFuZ2VzID0gW1xuICAgICAgICAvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MaXN0X29mX0hUVFBfc3RhdHVzX2NvZGVzXG4gICAgICAgIC8vIDF4eCAtIFJldHJ5IChJbmZvcm1hdGlvbmFsLCByZXF1ZXN0IHN0aWxsIHByb2Nlc3NpbmcpXG4gICAgICAgIC8vIDJ4eCAtIERvIG5vdCByZXRyeSAoU3VjY2VzcylcbiAgICAgICAgLy8gM3h4IC0gRG8gbm90IHJldHJ5IChSZWRpcmVjdClcbiAgICAgICAgLy8gNHh4IC0gRG8gbm90IHJldHJ5IChDbGllbnQgZXJyb3JzKVxuICAgICAgICAvLyA0MDggLSBSZXRyeSAoXCJSZXF1ZXN0IFRpbWVvdXRcIilcbiAgICAgICAgLy8gNDI5IC0gUmV0cnkgKFwiVG9vIE1hbnkgUmVxdWVzdHNcIilcbiAgICAgICAgLy8gNXh4IC0gUmV0cnkgKFNlcnZlciBlcnJvcnMpXG4gICAgICAgIFsxMDAsIDE5OV0sXG4gICAgICAgIFs0MDgsIDQwOF0sXG4gICAgICAgIFs0MjksIDQyOV0sXG4gICAgICAgIFs1MDAsIDU5OV0sXG4gICAgXTtcbiAgICBjb25maWcuc3RhdHVzQ29kZXNUb1JldHJ5ID0gY29uZmlnLnN0YXR1c0NvZGVzVG9SZXRyeSB8fCByZXRyeVJhbmdlcztcbiAgICAvLyBQdXQgdGhlIGNvbmZpZyBiYWNrIGludG8gdGhlIGVyclxuICAgIGVyci5jb25maWcucmV0cnlDb25maWcgPSBjb25maWc7XG4gICAgLy8gRGV0ZXJtaW5lIGlmIHdlIHNob3VsZCByZXRyeSB0aGUgcmVxdWVzdFxuICAgIGNvbnN0IHNob3VsZFJldHJ5Rm4gPSBjb25maWcuc2hvdWxkUmV0cnkgfHwgc2hvdWxkUmV0cnlSZXF1ZXN0O1xuICAgIGlmICghKGF3YWl0IHNob3VsZFJldHJ5Rm4oZXJyKSkpIHtcbiAgICAgICAgcmV0dXJuIHsgc2hvdWxkUmV0cnk6IGZhbHNlLCBjb25maWc6IGVyci5jb25maWcgfTtcbiAgICB9XG4gICAgY29uc3QgZGVsYXkgPSBnZXROZXh0UmV0cnlEZWxheShjb25maWcpO1xuICAgIC8vIFdlJ3JlIGdvaW5nIHRvIHJldHJ5ISAgSW5jcmVtZW50IHRoZSBjb3VudGVyLlxuICAgIGVyci5jb25maWcucmV0cnlDb25maWcuY3VycmVudFJldHJ5QXR0ZW1wdCArPSAxO1xuICAgIC8vIENyZWF0ZSBhIHByb21pc2UgdGhhdCBpbnZva2VzIHRoZSByZXRyeSBhZnRlciB0aGUgYmFja09mZkRlbGF5XG4gICAgY29uc3QgYmFja29mZiA9IGNvbmZpZy5yZXRyeUJhY2tvZmZcbiAgICAgICAgPyBjb25maWcucmV0cnlCYWNrb2ZmKGVyciwgZGVsYXkpXG4gICAgICAgIDogbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KHJlc29sdmUsIGRlbGF5KTtcbiAgICAgICAgfSk7XG4gICAgLy8gTm90aWZ5IHRoZSB1c2VyIGlmIHRoZXkgYWRkZWQgYW4gYG9uUmV0cnlBdHRlbXB0YCBoYW5kbGVyXG4gICAgaWYgKGNvbmZpZy5vblJldHJ5QXR0ZW1wdCkge1xuICAgICAgICBhd2FpdCBjb25maWcub25SZXRyeUF0dGVtcHQoZXJyKTtcbiAgICB9XG4gICAgLy8gUmV0dXJuIHRoZSBwcm9taXNlIGluIHdoaWNoIHJlY2FsbHMgR2F4aW9zIHRvIHJldHJ5IHRoZSByZXF1ZXN0XG4gICAgYXdhaXQgYmFja29mZjtcbiAgICByZXR1cm4geyBzaG91bGRSZXRyeTogdHJ1ZSwgY29uZmlnOiBlcnIuY29uZmlnIH07XG59XG4vKipcbiAqIERldGVybWluZSBiYXNlZCBvbiBjb25maWcgaWYgd2Ugc2hvdWxkIHJldHJ5IHRoZSByZXF1ZXN0LlxuICogQHBhcmFtIGVyciBUaGUgR2F4aW9zRXJyb3IgcGFzc2VkIHRvIHRoZSBpbnRlcmNlcHRvci5cbiAqL1xuZnVuY3Rpb24gc2hvdWxkUmV0cnlSZXF1ZXN0KGVycikge1xuICAgIGNvbnN0IGNvbmZpZyA9IGdldENvbmZpZyhlcnIpO1xuICAgIGlmICgoZXJyLmNvbmZpZy5zaWduYWw/LmFib3J0ZWQgJiYgZXJyLmNvZGUgIT09ICdUaW1lb3V0RXJyb3InKSB8fFxuICAgICAgICBlcnIuY29kZSA9PT0gJ0Fib3J0RXJyb3InKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gSWYgdGhlcmUncyBubyBjb25maWcsIG9yIHJldHJpZXMgYXJlIGRpc2FibGVkLCByZXR1cm4uXG4gICAgaWYgKCFjb25maWcgfHwgY29uZmlnLnJldHJ5ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gQ2hlY2sgaWYgdGhpcyBlcnJvciBoYXMgbm8gcmVzcG9uc2UgKEVUSU1FRE9VVCwgRU5PVEZPVU5ELCBldGMpXG4gICAgaWYgKCFlcnIucmVzcG9uc2UgJiZcbiAgICAgICAgKGNvbmZpZy5jdXJyZW50UmV0cnlBdHRlbXB0IHx8IDApID49IGNvbmZpZy5ub1Jlc3BvbnNlUmV0cmllcykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIE9ubHkgcmV0cnkgd2l0aCBjb25maWd1cmVkIEh0dHBNZXRob2RzLlxuICAgIGlmICghY29uZmlnLmh0dHBNZXRob2RzVG9SZXRyeSB8fFxuICAgICAgICAhY29uZmlnLmh0dHBNZXRob2RzVG9SZXRyeS5pbmNsdWRlcyhlcnIuY29uZmlnLm1ldGhvZD8udG9VcHBlckNhc2UoKSB8fCAnR0VUJykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBJZiB0aGlzIHdhc24ndCBpbiB0aGUgbGlzdCBvZiBzdGF0dXMgY29kZXMgd2hlcmUgd2Ugd2FudFxuICAgIC8vIHRvIGF1dG9tYXRpY2FsbHkgcmV0cnksIHJldHVybi5cbiAgICBpZiAoZXJyLnJlc3BvbnNlICYmIGVyci5yZXNwb25zZS5zdGF0dXMpIHtcbiAgICAgICAgbGV0IGlzSW5SYW5nZSA9IGZhbHNlO1xuICAgICAgICBmb3IgKGNvbnN0IFttaW4sIG1heF0gb2YgY29uZmlnLnN0YXR1c0NvZGVzVG9SZXRyeSkge1xuICAgICAgICAgICAgY29uc3Qgc3RhdHVzID0gZXJyLnJlc3BvbnNlLnN0YXR1cztcbiAgICAgICAgICAgIGlmIChzdGF0dXMgPj0gbWluICYmIHN0YXR1cyA8PSBtYXgpIHtcbiAgICAgICAgICAgICAgICBpc0luUmFuZ2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghaXNJblJhbmdlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gSWYgd2UgYXJlIG91dCBvZiByZXRyeSBhdHRlbXB0cywgcmV0dXJuXG4gICAgY29uZmlnLmN1cnJlbnRSZXRyeUF0dGVtcHQgPSBjb25maWcuY3VycmVudFJldHJ5QXR0ZW1wdCB8fCAwO1xuICAgIGlmIChjb25maWcuY3VycmVudFJldHJ5QXR0ZW1wdCA+PSBjb25maWcucmV0cnkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8qKlxuICogQWNxdWlyZSB0aGUgcmF4Q29uZmlnIG9iamVjdCBmcm9tIGFuIEdheGlvc0Vycm9yIGlmIGF2YWlsYWJsZS5cbiAqIEBwYXJhbSBlcnIgVGhlIEdheGlvcyBlcnJvciB3aXRoIGEgY29uZmlnIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gZ2V0Q29uZmlnKGVycikge1xuICAgIGlmIChlcnIgJiYgZXJyLmNvbmZpZyAmJiBlcnIuY29uZmlnLnJldHJ5Q29uZmlnKSB7XG4gICAgICAgIHJldHVybiBlcnIuY29uZmlnLnJldHJ5Q29uZmlnO1xuICAgIH1cbiAgICByZXR1cm47XG59XG4vKipcbiAqIEdldHMgdGhlIGRlbGF5IHRvIHdhaXQgYmVmb3JlIHRoZSBuZXh0IHJldHJ5LlxuICpcbiAqIEBwYXJhbSB7UmV0cnlDb25maWd9IGNvbmZpZyBUaGUgY3VycmVudCBzZXQgb2YgcmV0cnkgb3B0aW9uc1xuICogQHJldHVybnMge251bWJlcn0gdGhlIGFtb3VudCBvZiBtcyB0byB3YWl0IGJlZm9yZSB0aGUgbmV4dCByZXRyeSBhdHRlbXB0LlxuICovXG5mdW5jdGlvbiBnZXROZXh0UmV0cnlEZWxheShjb25maWcpIHtcbiAgICAvLyBDYWxjdWxhdGUgdGltZSB0byB3YWl0IHdpdGggZXhwb25lbnRpYWwgYmFja29mZi5cbiAgICAvLyBJZiB0aGlzIGlzIHRoZSBmaXJzdCByZXRyeSwgbG9vayBmb3IgYSBjb25maWd1cmVkIHJldHJ5RGVsYXkuXG4gICAgY29uc3QgcmV0cnlEZWxheSA9IGNvbmZpZy5jdXJyZW50UmV0cnlBdHRlbXB0XG4gICAgICAgID8gMFxuICAgICAgICA6IChjb25maWcucmV0cnlEZWxheSA/PyAxMDApO1xuICAgIC8vIEZvcm11bGE6IHJldHJ5RGVsYXkgKyAoKHJldHJ5RGVsYXlNdWx0aXBsaWVyXmN1cnJlbnRSZXRyeUF0dGVtcHQgLSAxIC8gMikgKiAxMDAwKVxuICAgIGNvbnN0IGNhbGN1bGF0ZWREZWxheSA9IHJldHJ5RGVsYXkgK1xuICAgICAgICAoKE1hdGgucG93KGNvbmZpZy5yZXRyeURlbGF5TXVsdGlwbGllciwgY29uZmlnLmN1cnJlbnRSZXRyeUF0dGVtcHQpIC0gMSkgL1xuICAgICAgICAgICAgMikgKlxuICAgICAgICAgICAgMTAwMDtcbiAgICBjb25zdCBtYXhBbGxvd2FibGVEZWxheSA9IGNvbmZpZy50b3RhbFRpbWVvdXQgLSAoRGF0ZS5ub3coKSAtIGNvbmZpZy50aW1lT2ZGaXJzdFJlcXVlc3QpO1xuICAgIHJldHVybiBNYXRoLm1pbihjYWxjdWxhdGVkRGVsYXksIG1heEFsbG93YWJsZURlbGF5LCBjb25maWcubWF4UmV0cnlEZWxheSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXRyeS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/gaxios/build/cjs/src/retry.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/gaxios/build/cjs/src/util.cjs":
/*!****************************************************!*\
  !*** ./node_modules/gaxios/build/cjs/src/util.cjs ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n// Copyright 2023 Google LLC\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nconst pkg = __webpack_require__(/*! ../../../package.json */ \"(rsc)/./node_modules/gaxios/package.json\");\nmodule.exports = { pkg };\n//# sourceMappingURL=util.cjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ2F4aW9zL2J1aWxkL2Nqcy9zcmMvdXRpbC5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG1CQUFPLENBQUMsdUVBQXVCO0FBQzNDLG1CQUFtQjtBQUNuQiIsInNvdXJjZXMiOlsid2VicGFjazovL2hvbWV3b3J0aC1haS1wcm9wZXJ0eS12YWx1YXRpb24vLi9ub2RlX21vZHVsZXMvZ2F4aW9zL2J1aWxkL2Nqcy9zcmMvdXRpbC5janM/Y2Q2MCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIENvcHlyaWdodCAyMDIzIEdvb2dsZSBMTENcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuY29uc3QgcGtnID0gcmVxdWlyZSgnLi4vLi4vLi4vcGFja2FnZS5qc29uJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHsgcGtnIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlsLmNqcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/gaxios/build/cjs/src/util.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/gaxios/package.json":
/*!******************************************!*\
  !*** ./node_modules/gaxios/package.json ***!
  \******************************************/
/***/ ((module) => {

module.exports = /*#__PURE__*/JSON.parse('{"name":"gaxios","version":"7.1.2","description":"A simple common HTTP client specifically for Google APIs and services.","main":"build/cjs/src/index.js","types":"build/cjs/src/index.d.ts","files":["build/"],"exports":{".":{"import":{"types":"./build/esm/src/index.d.ts","default":"./build/esm/src/index.js"},"require":{"types":"./build/cjs/src/index.d.ts","default":"./build/cjs/src/index.js"}}},"scripts":{"lint":"gts check --no-inline-config","test":"c8 mocha build/esm/test","presystem-test":"npm run compile","system-test":"mocha build/esm/system-test --timeout 80000","compile":"tsc -b ./tsconfig.json ./tsconfig.cjs.json && node utils/enable-esm.mjs","fix":"gts fix","prepare":"npm run compile","pretest":"npm run compile","webpack":"webpack","prebrowser-test":"npm run compile","browser-test":"node build/browser-test/browser-test-runner.js","docs":"jsdoc -c .jsdoc.js","docs-test":"linkinator docs","predocs-test":"npm run docs","samples-test":"cd samples/ && npm link ../ && npm test && cd ../","prelint":"cd samples; npm link ../; npm install","clean":"gts clean"},"repository":"googleapis/gaxios","keywords":["google"],"engines":{"node":">=18"},"author":"Google, LLC","license":"Apache-2.0","devDependencies":{"@babel/plugin-proposal-private-methods":"^7.18.6","@types/cors":"^2.8.6","@types/express":"^5.0.0","@types/extend":"^3.0.1","@types/mocha":"^10.0.10","@types/multiparty":"4.2.1","@types/mv":"^2.1.0","@types/ncp":"^2.0.1","@types/node":"^22.0.0","@types/sinon":"^17.0.0","@types/tmp":"0.2.6","assert":"^2.0.0","browserify":"^17.0.0","c8":"^10.0.0","cors":"^2.8.5","express":"^5.0.0","gts":"^6.0.0","is-docker":"^3.0.0","jsdoc":"^4.0.0","jsdoc-fresh":"^4.0.0","jsdoc-region-tag":"^3.0.0","karma":"^6.0.0","karma-chrome-launcher":"^3.0.0","karma-coverage":"^2.0.0","karma-firefox-launcher":"^2.0.0","karma-mocha":"^2.0.0","karma-remap-coverage":"^0.1.5","karma-sourcemap-loader":"^0.4.0","karma-webpack":"^5.0.1","linkinator":"^6.1.2","mocha":"^11.1.0","multiparty":"^4.2.1","mv":"^2.1.1","ncp":"^2.0.0","nock":"^14.0.0-beta.13","null-loader":"^4.0.0","pack-n-play":"^3.0.0","puppeteer":"^24.0.0","sinon":"^21.0.0","stream-browserify":"^3.0.0","tmp":"0.2.5","ts-loader":"^9.5.2","typescript":"^5.8.3","webpack":"^5.35.0","webpack-cli":"^6.0.1"},"dependencies":{"extend":"^3.0.2","https-proxy-agent":"^7.0.1","node-fetch":"^3.3.2"}}');

/***/ })

};
;